高频疑难题
==============================================

PS：大部分答案个人已查阅文档找到出处并订正，有误的部分应该很少，不对之处望大家指正。


1.以下哪些设计违反了CSEC Golden Rules （）
A.考虑易用性，设备管理面提供记住密码功能
B.应该采用标准的密钥派生函数如PBKDF2
C.为保证设备开局免软调，必须做到与现网设备兼容，因此协议缺省关闭认证以及加密功能
D.记录所有的配置命令执行日志再远程系统日志服务器上
参考答案：AC。D项描述是CSEC推荐做法，所以D没有违反规则。

搞清必选审视项 adcp/cdcp/pdcp
一句话总结：ADCP仅测试闭环和开发落地，CDCP不选需求，PDCP不选威胁分析。
3.85    如下哪些是ADCP必选审视项？
A 产品在上市阶段在可信要求上是否做到该行业标杆
B测试报告中与可信产品定义相关的测试闭环验收结果
C 可信要求规划的开发落地质量（缺陷率和遗留缺陷等）
D与可信相关的目标和资源投入
选BC
3.87    如下哪些是Charter/CDCP必选审视项？
A 产品在上市阶段在可信要求上是否做到该行业标杆
B 业务场景/威胁分析的要求，韧性要求，认证及等级要求
C 可信产品定义的需求，代码重构和技术债务的需求和工作量
D 可信带来的代码重构和技术债务
选ABD
3.88    如下哪些是PDCP必选审视项？
A 可信产品定义的需求，代码重构和技术债务的需求和工作量
B 业务场景/威胁分析的要求，韧性要求，认证及等级要求
C 产品在上市阶段在可信要求上是否做到该行业标杆
D 与可信相关的目标和资源投入
选ACD，威胁分析是CDCP
知识点：C是概念，P是计划，A是可获得性。
CDCP：concept decision check point (CDCP)概念决策评审点
PDCD:plan decision check point (PDCP)计划决策评审点
availability decision checkpoint (ADCP)可获得性决策评审点
CDCP（concept decision check point，概念决策评审点）评审：产品包、市场、业务潜力、开发计划等
PDCP（plan decision check point，计划决策评审点）评审：业务潜力、市场理解、承诺、开发计划等
EDCP（ESS decision check point，早期销售决策评审点）评审：业务展望、产品质量、交付准备度、风险等
ADCP（availability decision check point，可获得性决策评审点）评审：发货质量、交付准备度、业务展望、发布与宣传、风险等

tr1阶段输出的没有，分解分配表
6（多选）如下安全相关的文档，需要在 TR1 阶段输出的有：
A 需求敏感特性自检
B 安全性威胁分析及需求说明书
C 红线解决方案落地自检表
D 安全需求分解分配表
选AB。需求特性自检和需求说明。已确认没有D。
  

断言检查细节，没有测试替身替代 
 过度使用断言检查每个细节，致使整个测试变得脆弱，考虑什么手段进行重构？ 
A、用测试替身替代外部依赖，根据需要将其封装到适配层中
B、将非强相关的用例进行拆分
C、识别无关细节，并将其从测试中移除
D、使用 bool 运算符替换位运算符
参考答案：选BC。已确认A跟脆弱的测试有关，D肯定跟断言没啥关系。
  


使用UML对系统进行动态建模，不能使用类图。
要对一个企业的工作流程进行建模，活动图最重要。

以下哪些行为可以不视为Hack Back（）
A.  gi作为被攻击方，在自身网络内部进行的防御行为；
B.  经批准或客户授权，g在自运营网络中或客户网络中进行的渗透测试或其他安全测试活动。

以下关于软件建模的三种模型描述正确的有：全选。
搬移没有重新组织函数。消除if/else，全选。
ABCE，测试框架的考虑与发布时间无关

对下面代码段，请忽略不同语言的规范和语法差异，哪个重构方法最好？（） 



顺序时序图，曹操：虚线是组件的生命线
8：曹操刘备顺序图问题：图中的虚线称作“生命线”，表示一个对象在其时间周期内的存在
分析下面时序图/顺序图，并指出哪种说法是正确的？（C） 
参考答案：C。真题，重点理解，可能会改成旅客预订旅游地，让选出整个时序图流程各步骤。
在时序图中，对象生命线（Object Lifeline）表示扮演一个特定角色的实例。
“求战”，“怎么办”以及”火烧连营”这3条消息是有严格次序的；“:曹操”，“:刘备”，“:孔明”代表3个对象，并不是3个类；求战”这条消息应该是将调用“刘备”的某一操作。



【7.13更新】54. 有这样一段代码，希望能够提升方法的可扩展性和可读性，在不考虑组件依赖关系和耦合度的情况下，请选择最适合的优化办法（其中 User 和 Passport 是已有类，User 包含userId 和 userName，Passport 包含 passportId 和 passportExpirationDate，代码中省略了实现细节），请忽略不同语言的规范和语法差异。（ ）
```public class PassportChecker {
public CheckResult checkUserAndPassport(UUIDuserId, String userName, UUID
passportId, Instant passportExpirationDate)
{ /* (省略实现) */ }
} 
```
D. 引 入 参 数 对 象 （ Introduce Parameter Object ）： 
``` public class
PassportCheckerParam {private UUID userId; private String userName; private UUID
passportId; private Instant passportExpirationDate; /* (省略 Getter 和 Setter) */ } 
```
```  public  class  PassportChecker  {public  CheckResult
checkUserAndPassport(PassportCheckerParam paramObj)) { /* (省略实现) */ } }
 ```
. 引入参数对象（Introduce Parameter Object）和保持对象完整性（Preserve
WholeObject）：
 ``` public class PassportCheckerParam { private User user; private
Passportpassport; /* (省略 Getter 和 Setter) */ } `````` public class PassportChecker
{ public CheckResult checkUserAndPassport(PassportCheckerParam paramObj)) { /*
(省略实现) */ } } 
```

C. 保持对象完整性（Preserve Whole Object）：
 ``` public class PassportChecker { public
CheckResult checkUserAndPassport(User user, Passport passport)) { /* (省略实现)
*/ } }
 ```
D. 原有实现已经足够可扩展和表意，无需优化，所以其它三个选项都属于过度优化。
选C，已分析确认，应该是保持对象完整性，将参数整合到参数对象中。
题目分析：
选项 A：使用了引入参数对象（Introduce Parameter Object），但是仅仅是用参数对象代替了全部输入，看似提升了可扩展性，但实际上没有实质性的优化。
选项 B：使用了引入参数对象（Introduce Parameter Object）和保持对象完整性（Preserve WholeObject），但是破坏了可读性，并增加了额外的代码组件，属于过度优化。 
选项 C：按照方法本身的职责，使用保持对象完整性（Preserve Whole Object）改进了可扩展性和可读性，恰到好处。 
选项 D：从字面上看，该方法的入参数据来自于两个对象，一个是 User，一个是 Passport，破坏了对象完整性，所以需要优化。



  
应该是ABC，switch重构，用查表或者工厂创建对象和消息的关系，以及职责链
52. 某产品软件中有一段消息处理程序，所处理的消息有很多种类型，这些消息有公共的消息头格式，处理代码根据收到的消息获取消息头中的类型调用具体的消息处理，目前代码使用 switch 语句判断不同消息类型，随着消息类型增多现在开发人员希望重构代码消除switch 语句降低代码复杂度并方便扩展消息类型，可以采用下面那些方法（）
A. 将 switch 语句改成 if else 判断，并按照每几个类型判断（比如 5 个）提取成子函数，这样既可以有效降低函数圈复杂度，又没有风险
B. 按照消息不同的类型和子类型设计消息类继承关系，将定义消息类继承树，处理消息时通过工厂创建对应具体消息对象处理
C. 使用表驱动方式重构，处理消息时根据消息类型查表找到对应处理方法执行
D. 使用职责链（chain of responsibility）模式，每个消息类型实现一个处理对应类型消息的处理器，处理消息时按照职责链执行处理
选BCD。消息继承、表驱动，职责链模式。


查阅资料确定csrf攻击用什么消减。
3.防止CSRF攻击(Cross-site request forgery, 跨站请求伪造)的主流方法是()
A.校验Http Referrer
B.校验Cookie中token
C.隐藏域token
D.校验cookie中的会话标识
 选C，分析：A可能会被绕过，B校验cookie中的token是做不到防护的，D更是做不到防护，故选C



（单选）消减CSRF的方法（）
A. 校验http referrer
B. 校验cookie的token
C. 校验cookie的会话ID
选A，【解析】优选措施是验证HTTP Referer；没有隐藏域token时，再选校验http referrer


（多选）CSRF的防御措施包含（）
A. 验证HTTP Referer字段
B.在请求地址中添加token并验证
C.在HTTP头中自定义属性并验证,也是Token机制
D.当用户关闭页面时要及时清除认证cookie
 选ABCD，已验证。

类图/uml图是什么，如何应用
类图是UML图的子类，常用于软件建模中，具体应用见软件建模习题。

uml各种类型的图表示什么关系
组合，总体和局部，公司和部门；聚合，总体和个体，群体和个人；
真题。正确说法：组件图和部署图可以结合在一起，描述哪些组件在哪些节点上运行。
错误说法有：
1）组件图(Component Diagram)描述系统中组件之间的物理关系。
2）概念建模用于定义需要软件管理和处理的数据/信息，以及这些信息之间的关系，一般用数据视图表示，如类图，活动图。
3）软件建模是通过不同视角，采用不同的模型图对一个软件系统进行的完整描述。


3：人-教师-教授是依赖关联关系，实线箭头，循环链表-队列是聚合关系，实线空菱形。

UML图，如果A是父类，B是其子类，B由1个C和N个D组成；画出UML图，泛化和组合关系绘制。
AB之间，泛化用实线三角，指向父类；
B和C、D，组合用实线实菱形，指向组合成的B。
指向统统是由小指向大范围。只有依赖和实现是虚线。

一个经理管N个雇员，不是关联关系，用1...N表示存在多重关系
管理的关系不是关联，不是关联，不是关联。
 一个经理对应多个员工，多个员工对应一个经理，以下UML图表示正确的是：不是关联，没有箭头、菱形、三角形

老师、学生、班级的UML图
学生和老师是关联关系，学生不能没有老师。
学生和班级是聚合关系，学生个体聚合成班级整体。
学生和心脏是组合关系，心脏是学生总体的局部，组合成学生。
关系由弱变强：依赖，关联，聚合，组合，泛化（继承），实现；泛化和实现是同级强度。图形绘制：箭头、菱形、三角
依赖和关联是虚线与实线之分，都是箭头
聚合与组合是空心和实心之分，都是菱形
泛化和实现是实线与虚线之分，都是三角，抽象和具体
【每日一题系列】选B
选B，FEMA，潜在故障
选BCD。组件化是分离接口的方式。
参考答案： B，哈希不能对口令加密。
A:  HMAC-SHA256算法
C: 通过HMAC等哈希算法对数据进行转换
D: HMAC-SHA256算法
参考答案： B，1024RSA，算法强度80
RSA 1024 ->80
RSA 2048 -> 112
RSA 3096 -> 128
RSA 7680 -> 192
RSA 15360 -> 256
参考答案： D

参考答案：BD，结构型模式，不修改代码则是适配器和桥接模式

参考答案：ABCD 



1.为了防止长期使用的口令被恶意猜测或破解，下面对口令提供的安全防护，正确的是：
A.系统应该具有限制人机账号口令最短使用期限和最长使用期限的能力
B.用户修改自己账户口令时，系统禁止新口令与前N个历史口令重复，此个数可配置
C.口令即将达到最长有效期限，应该提升用户修改口令
D.管理员修改自己的口令可以不用验证旧口令
选ABC


1.对于下面检查用户状态的函数，存在条件判断较复杂的问题，可以使用()重构方法提高可读性A.分解条件式，将每一个if条件表达式独立成一个函数（抽取以赋予意义，自注释）
B.以卫语句替代嵌套条件
C.引入解释性变量，将相关条件统一用一个临时变量，以此变量名来解释用途
D.将临时变量内联化，消除不合理的封装
选A

1.以下关于密钥管理安全说法中错误的是：
A.系统中同一密钥同时用于加密、认证授权，符合密钥敏捷性
B.密钥协商过程中避免中间人攻击，密钥协商过程应该有身份认证机制保护
C.应该避免根密钥硬编码，否则容易被质疑后门
D.IPSec/SSH协议都具有密钥协商机制
选A，同一秘钥多用途，错。

1.在登录认证过程中，下面哪项是最有效的口令防暴力破解消减措施
A.定期更新账号口令
B.增加认证验证码校验
C.口令长度至少10个字符
D.口令中强制要求增加特殊字符
选B

1.  （单选）下列做法归属于安全红线问题的是（）
A. 证书指纹算法使用SHA1
B. 产品部署中重要的资源变更没有记录日志
C. 日志内容包括用户名
D. 未登陆就能访问产品联机帮助
选B

78. (单选)某产品为了防范网络攻击，采取了如下防范措施，其中不属于韧性技术或者架构的措施是：
A. 按照关键模块和用户优先级进行优雅降级，确保攻击造成的影响最小化
B. 组网上通过合理配置实现管理面、控制面、用户面的三面隔离
C. 软件采用云化部署，为了安全运维，部署在相同的操作系统上
D. 监控可视化，可及时响应，及时维护业务
参考答案：C。C是常见的降低风险措施，没有啥主动的韧性技术。

特性需求分析包括客户场景分析、客户界面影响分析、特性间依赖和影响风险、DFX分析、功能影响分析等。其中，特性间依赖和影响分析主要分析各需求特性之间的依赖关系及其影响，要解决的是下述哪些问题（ ）选ACD。没有客户界面变更。

下列设计模式和安全相关的是（）
信任环、自由联盟身份联合模式。。。选ABC，没有抽象工厂。




选AB

需求分析一般会分别从特性和功能等维度进行分析，其中功能维度的需求分析活动包括概念建模、功能建模、系统行为建模等。下述选项针对功能维度的分析活动描述错误的是（）选A。原因是，概念建模只管抽象，不管实现，不需要定义信息间的关系。

3.在新增一种网元设备时往往需要先对相关的管理对象进行概念建模，对于这种需求分析阶段的概念建模，下列做法错误的是（）
A. 建模不必细化到完整的细节，比如类的属性具体类型可以不定义
B. 不要为系统的方方面面都建模，识别出对系统重要概念即可
C. 不仅要描述问题本身，还要关心如何实现
D. 不仅要描述对象，还要描述对象之间的关系
选C，题目分析：A 概念建模在描述对象的同时，还要描述其之间的关系；B 概念建模只需描述问题本身，不用关心如何实现；C 建模过程是识别关系概念，不需面面俱到；D 建模信息也是抽象的，在该阶段不需定义属性类型

56. 某设备软件有一消息处理函数，其代码段如下所示，考虑其循环体内判断逻辑复杂，拟对其进行重构：
```
void ProcOverheadMsg(const uint32 maxCount, const uint32 msgQueueId) {

    uint32 index = VOS_NULL_LONG;

    uint32 msgNum = GetMsgNum(cellQueueId);

    bool flag = false;

    bool timeFlag = false;

    for (uint32 count = 1; count < maxCount; count++) {

        timeFlag = false;

        flag = ((0 != (count % 6)) || ((VOS_NULL_LONG == msgNum) || (0 ==msgNum)));

        if (true == flag) {

            index = GetFirstNode(SPEED_CTRL_LIST_HEAD, 0);

            if(VOS_NULL_LONG != index) {

            timeFlag = true;

            ProTimerList(index);

            continue;

            }

        }

        flag =((0 == (count % 6)) || (false == timeFlag));

        if (true == flag) {

            flag = ((VOS_NULL_LONG!= msgNum) && (0 != msgNum));

            if (true == flag) { msgNum =ProcOverheadInfo(msgNum); }

        }

    }

    return;

}
```
经分析优化，重构后的函数为：
```
bool IsMsgNumValid(uint32 msgNum) {

    return ((msgNum != VOS_NULL_LONG) && (msgNum != 0));

}



void ProcOverheadMsg(const uint32 maxCount, const uint32 msgQueueId) {

    uint32 index = VOS_NULL_LONG;

    uint32 msgNum = GetMsgNum(cellQueueId);

    for (uint32 count = 1; count < maxCount; count++) {

        if(((count % 6) != 0) || !(IsMsgNumValid(msgNum))) {

            index = GetFirstNode(SPEED_CTRL_LIST_HEAD, 0);

            if (index != VOS_NULL_LONG) {

                ProTimerList(index);

                continue;

            }

        }

        if (IsMsgNumValid(msgNum)) { msgNum = ProcOverheadInfo(msgNum); }

    }

    return;

}
```
针对本次重构，请忽略不同语言的规范和语法差异，如下分析正确的是（ ）
A. 原函数通过状态标记 flag 更能清晰反应处理逻辑，且每个标记都是必须的
B. 重构后的函数功能将判断条件合并太多，导致功能与原函数不一致
C. 重构后的函数功能和原来函数功能是一致的
D. 函数循环体内“if (IsMsgNumValid (msgNum))”是多余的，可以直接删除，不影响功能
重点真题。考生选择答案：C，该结果：正确
题目分析：考试代码坏味道及重构方法。A 重构后功能保持不变，正确；B 不能删除该语句，否则逻辑与原函数不一致；C 功能未变；D 原函数通过条件提取方法可以看出“flag = ((0 ==(ulCount% 6)) || (false == timeFlag));”就冗余的，timeFlag 也完全没有价值。

45. 下面哪个 UML 适用于描述复杂算法的执行流程：
（A）活动图
（B）类图
（C）状态图
（D）用例图
选A。活动图来描述复杂算法流程。

5. 管理面所有用户的活动都要有日志记录，包括
A. 用户登录和退出
B. 锁定账号被自动解除
C. 用户所有非查询类业务操作以及结果
D. 用户的账号被锁定
选ABCD

37. 设计模式一般被分为三大类，其中行为模式用于描述程序在运行过程中复杂的流程控制，下列模式属于行为模式的有:
A. 观察者模式
B. 适配器模式
C. 桥接模式
D. 状态模式
选AD，BC是结构型模式

36. 安全验证码的设计要求是
A. 验证码必须是单一图片，有背景干扰
B. 验证码字符串要求随机生成，随机字符串必须是大小写字母数字
C. 验证码可在短期内多次使用
D. 验证码内容不能与客户端提交的任何信息相关联
选ABD。验证码不能短期多次重复使用。

34. 安全设计中，传输安全的设计原则，应该包括
A. 选择一种"合适"的安全传输协议
B. 算法原则只需考虑安全性原则，无需考虑性能
C. 考虑建立"逃生策略"，避免因证书加载失败、错误配置等异常导致的通讯中断
D. 无需考虑兼容使用"非安全协议"的老版本
选AC


30. 关于 STRIDE 威胁建模方法，以下理解正确的是：
A. STRIDE 要先绘制数据业务流图，在针对其中元素对应的威胁逐个分析，找到缺陷和削减措施；
B. 威胁库(威胁矩阵)建设，主要是分析威胁对业务的影响，已有的削减措施，攻击的可能性，并识别系统存在的缺陷；
C. STRIDE 方法能对某个威胁点进行深入全面的攻击路径分析，但是标准化程度低，适合安全专业组织/个人使用;
D. STRIDE 威胁分析通过资产被攻击的可能性及分析攻击的后果来分析安全风险。
选AB，选项中D项是TVRA方法的思路。【7.14更新，感谢评论区指正】
14. 对于变量的多个不同取值有不同的处理时，常用switch语句，不良的switch语句产生代码坏味道，对于switch的代码重构，以下说法正确的是：
A. switch语句一般至少有3以上的圈复杂度，为了降低圈复杂度，switch语句应该重构掉；
B. switch语句效率高，应该以效率优先的原则避免重构它；
C. 如果一个switch语句case数量较少，只是执行简单的行为，且评估未来增加case的可能性较小，就没有重构的必要了；
D. switch语句会造成圈复杂度高，为了满足平均圈复杂度小于5的要求，将每4个case语句封装成一个函数，将大switch语句拆分成多个小函数组合。
选C。

8. 系统中有一个全局资源类 X，只需要对外提供一个实例供使用者调用，应采用哪种设计
模式：
A. 使用外观模式，为 X 提供一个统一的访问接口
B. 将抽象工厂模式应用于 X
C. 将单实例模式应用于 X
D. 利用备忘录模式获取 X 的快照
选C，注意到只提供一个实例，就是单例模式

10. 有一个论坛网站，为了限制用户在论坛发布不当言论，需要对发布和评论内容进行过滤，这些过滤规则有很多种，一般需要多个规则同时过滤通过才可以正常发布，根据场景需要不改变单个规则的前提下，动态增加和调整规则的组合，应该使用下面哪种设计模式
A. 职责链模式
B. 观察者模式
C. 迭代器模式
D. 装饰模式
选A。过滤器有多重规则，是一种串联结构，只有所有规则通过才能发布，所以是职责链。

2. 关于隐私保护设计要求，以下做法正确的是
A. 某产品需要收集并存储、使用用户个人数据，可以不用提供隐私声明
B. 产品存储用户的信用卡 CVV 号，可以不用做匿名化处理
C. 某产品使用 HTTP 协议跨网络传输大批量的用户手机号码
D. 产品存储了用户登录时的验证码，可以不用做匿名化处理
选D，验证码没关系

11. 设计模式中关于结构型模式，以下说法正确的是
A. 结构型模式可以在不破坏类封装性的基础上，实现新的功能
B. 结构型模式主要用于创建一组对象
C. 结构型模式可以创建一组类的统一访问接口
D. 结构型模式可以在不破坏类封装性的基础上，使得类可以通不曾估计到的系统进行交互
选ACD

9. 在开发者测试设计和实现中，过度的使用断言检查每个细节，致使整个测试变得脆弱，重构手段有：
A. 识别无关细节并将其从测试中移除。
B. 将非强相关的测试部分进行拆分测试
C. 使用布尔运算符替换换位运算符
D. 使用良好的函数命名使其满足自解释的要求
选AB。

【存疑】7. 产品在对敏感数据进行加密时，以下哪些方式是被完全禁止使用的
A. 自行定义的通过变形/字符移动/异或等方式执行的数据转换算法
B. 通过编码的方式如(Base64数据编码)实现数据加密
C. 采用公司研发的私有加解密算法实现
D. 采用MD5算法实现数据加密
7.13更新：感谢李卓远指正。应该选：ABCD，公司内部研发的私有加密算法也是私有的，有风险；D是不安全算法，一般是禁止使用不安全密码算法的，虽然特殊场景可以例外使用，但是MD5不能用于敏感数据的加密算法。个人认为选：ACD，私有的、非标准的、用编码方式的被完全禁止  



65、下面需求分析的结果和描述示例，哪些不满足需求分析的质量要求？
A.对特殊的异常场景，不做分析。
B.特性的可交付性和服务代表要求不一致。
C.对性能的描述：整体系统的响应时间不小于2秒。
D.需求的来源和开发阶段的影响，通过IR/SR/AR进行了关联。
答案：ABC。C对性能的描述不对，是质量属性。

70、当应用工厂方法模式时要考虑下面哪些问题？
A.必须提供工厂方法的默认实现
B.参数化工厂方法
C.所有语言的特点
D.使用模板以避免创建子类
答案：BCD。工厂方法要避免实现，直观抽象关系。

74、关于重构，下列说法错误的是
A.重构尽量以微小的步伐修改程序，直接重构一个模块是非常冒险的行为，需要谨慎应对。
B.程序"如果没有坏(功能可用)，就不要去修复它"，是代码是否需要选择重构的必要条件。
C.重构方法非常复杂，重构也常常会引入问题，普通开发人员不要自行重构一段功能正常的代码。
D.重构一定要在开发过程中作为独立的阶段实施，并由独立的团队执行，便于版本进度和质量控制。
E.使用各种有利于解耦的设计模式常常会导致代码执行流程变长，对于性能要求高的代码，一定要少用设计模式。
答案：BCDE

68、某软件公司承接了为某工作流语言开发解释器的工作。该工作流语言由多种活动节点构成，具有类XML的语法结构。用户要求解释器工作时，对每个活动节点进行一系列的处理，包括执行活动、日志记录、调用外部应用程序等，并且要求处理过程具有可扩展能力。针对这种需求，公司采用一下哪个设计模式最为恰当？
A.适配器模式(ADAPTER)
B.迭代器模式(ITERATOR)
C.访问者模式(VISITOR)
D.观察者模式(OBSERVER)
答案：C。对每个活动节点进行访问，然后做相应处理，而不是消息传递类用观察者模式。

1.在测试的系统(通过因特网订购书)中，有下面三个参数:
Number of Books：(Few, Many)
Sum : (Low, Middle, High)
Membership card (None, Silver Card, Gold Card)
如果用pair-wise方法设计测试用例，需要()个测试用例可以满足要求()
A.3
B.6
C.9
D.18
选C。
分析：
pair-wise，我们需要的是在一组测试用例中能够保证至少一个用例中的每个其他变量的每个取值都配对过。

参考解释：http://www.51testing.com/mobile/view.php?itemid=3707754
通过用例配对，减少重复用例。如全面测试需要：3*3*2=18，而pair-wise，凑对的方式，已经出现的就再分别跟few/many分别搭对了，只要各跟一对即可。所以用例就降低了一半：3*3=9
AC(全组合): 所有因子取值个数的乘积

Pair-Wise: 最多因子取值个数 * 次多因子取值个数，所以如果有4个因子，每个因子各有5,4,3,2中可能，则需要5*4=20个用例
EC(单一选择组合): 所有因子中取值最多的那个因子的取值个数
BC(基本选择组合): 所有因子取值个数和 - 因子个数 + 1

4.日志是安全应用设计的重要关注点，日志在存储时候应该遵守原则的错误说法()
A.日志可以支持顶起备份
B.日志可以转存为其他格式
C.不同类型日志应该分别记录保存
D.用户不可配置日志存储时间
选D5.数字信封是指发送方使用（）来加密对称密钥后所得的数据？
A.接收方的公钥
B.发送方的公钥
C.接收方的私钥
D.发送方的私钥
选A6.在数字信封加密方式下，真正用来加解密通信过程中所传输数据(明文)的密钥是()
A.非对称算法的公钥
B.对称加密密钥
C.非对称算法的私钥
D.CA中心的公钥
选B

13.以下哪种威胁会破坏系统的机密性：
A.存储的数据内容被替换、篡改
B.网站遭到DOS攻击造成服务器宕机、数据丢失
C.数据传输过程中的口令信息遭到中间人攻击窃取
D.黑客用暴力破解攻击得到了管理员账号的口令
选C

1.  以下哪个不是会话认证前发生的问题
A.基于IP的攻击
B.基于应用层协议的攻击(如HTTP/DNS等)
C. DDoS攻击
D.会话标识可猜测攻击
选D，真题。

20.关于威胁建模，以下理解正确的是
A．STRIDE是一种以攻击者为中心的建模方法，主要考虑攻击者可以如何对系统实施攻击，以及采用的攻击模式和方法，给攻击者画像的威胁建模方法
B．攻击树是一种以资产为中心，关注资产如何遭受攻击，以及如何应对的威胁建模方法
C．STRIDE是一种以软件为中心，关注正在建设的软件或系统，考虑软件/系统可能面临的威胁以及消减措施的威胁建模方法
D．攻击树一般不用于威胁建模
 选C

31. 临时字段是指在特定环境下有意义，离开这个环境，它们就什么也不是了，对于临时字段描述错误的是：
A. 可以通过提炼类将临时字段和操作它们的所有代码提炼到一个类中来重构
B. 将临时字段的所有赋值点都使用函数替换
C. 特定环境相关的代码需要重构到一个集中的地方，避免新增功能出现霰弹式修改
D. 临时字段可能会导致代码可读性变差
 选B


2	√ 三权分立是那种安全设计模式的子原则 B
A,最小权限原则
B权限隔离原则
C其它两个肯定不是，不记得了
是基于角色的访问控制，“三权分立”模三权分立”模型一般实现是默认设置3类角色，3类角色的系统账号权限相互独立，权职分离

参数对象化

选D,基于平台侧改，门面模式，产品要啥拿啥，从而与平台解耦

该类型题目要理解，刚考了，多选题中选择测试用例来满足路径覆盖

数据泥团，参数过长，需要封装或者参数对象化来解决

高频题目，选D，pair-wise用力个数：最高可能数*次高可能数

高频，刚考了原题，应该是D，物理层太过纵深，有点过了。C合理风险，可以接受，不一定非要消减。

外观（门面）模式，只有一个对外接口。

刚考了原题。

考了原题，选BCD


1.  设计模式中关于结构型模式，以下说法正确的是
A. 结构型模式可以在不破坏类封装性的基础上，实现新的功能
B. 结构型模式主要用于创建一组对象
C. 结构型模式可以创建一组类的统一访问接口
D. 结构型模式可以在不破坏类封装性的基础上，使得类可以通不曾估计到的系统进行交互
选ACD选BCD。重要，需理解。结构型模式如适配器、门面模式主要用途都不是拿来创建一组对象，而是来整合接口。


考过。选BC。

可以参数化对象类型，非要用基本类型。

童子军，无情重构。
又是uml图。必须掌握。

真题。选BCD。

选D，真题。
真题，选A，不能又查询又创建，不符合单一功能。
真题，重点理解。
真题，重点理解。分析，全路径覆盖，所有可能的组合，用例数：3*2
 
真题。
注意跟安全设计模式里的原则，三权分立时，选的不是最小化权限（可信设计里的原则），而是权限隔离原则（这才是跟安全设计模式有关）。


防止权限升级，方法：最小化权限，沙箱隔离

C应该是指用户名

刚考过，这题是多选，应该全选。

assert优化，两种解决方案，删除无关细节；拆分用例。

4	可信安全设计习题
________________________________________

2：以下哪种操作不强制要求记录日志：()
A：注销登录
B：命令行查询操作
C：帐户锁定
D：帐户自动解锁和手动解锁
选B

（单选）机机接口的防暴力破解，可以采用以下哪种方案(D)

A. 仅使用IP白名单
B. 锁定IP
C. 仅使用账号锁定
D. IP白名单+长密码（16字符以上满足复杂度要求）+告警/日志
选D


（多选）禁止采用如下哪些算法进行口令加密（）
A. RSA
B. DES
C. SKIPJACK
D.MD5
参考答案：BCD
7.13更新解析：DES和MD5是绝对禁止的，SKIPJACK也是禁止的，而RSA在1024位以下才是禁止的。参见红线观察项：
【红线观察项】禁止使用业界已知不安全的加密算法,DES/3DES（除密钥K1≠K2≠K3外的场景）/SKIPJACK/RC2/RSA（1024位及以下）/MD2/MD4。


3.15    产品应该规划独立的北向接口用户，原则上人机账号不能用于机机接口，机机账号不允许具备登录人机界面的能力，人机账号和机机账号不能是相同的账号。
3.16    数据流信息泄漏会破坏系统的机密性。
3.18    消减措施应基于风险来给出
3.19    测试阶段不会引入安全风险。
3.20    ASTRIDE面向软件，攻击树面向攻击，TVRA面向资产。
3.23    证书指纹算法使用SHA1不是安全红线问题。
3.24    PBKDF2是标准的密钥派生函数
3.25    在有实际需求时，允许产品使用不安全的协议，但必须同时支持安全的协议。
3.26    使用Coverity扫描，分析实际风险，为“高”的漏洞（CVSS 7分及以上），必须进行解决或规避。
3.27    漏洞扫描测试越早开展越好（如TR4A），避免没有足够时间分析处理漏洞。公司指定使用Nessus进行扫描。
3.29    嵌入式软件包也应该做防病毒检查。
3.30    Web应用的最终用户portal和管理portal也同样需要考虑隔离，如部署在不同的物理服务器上；如果是合设，考虑通过端口隔离。
3.32    精确位置指经纬度、GPS等，基站定位属于一般位置信息。
3.33    对称加密：推荐AES，不推荐RC4，3DES。哈希算法：推荐SHA256，不推荐SHA1，MD5。非对称加密：RSA。密钥交换：DH, ECDH。
3.34    禁止使用SSL2.0，SSL3.0协议，TLS1.0协议仅可遗留使用，推荐使用TLS1.1, TLS1.2版本。
3.35    对称加密算法运算速度快，密钥长度短，密文长度少，安全性容易证明，缺点是：密钥分发困难，不可用于数字签名。
3.36    非对称加密算法密钥分发容易，可以用于数字签名，缺点是：运算慢，密文长度剧烈增长，密钥长度长，安全性不容易证明。
3.37    中间人攻击：双向认证，数字证书认证，公私钥对认证。
3.38    重放攻击：引入时间戳，序列号，随机数等时变参数。
3.39    反射攻击：双方采用不同的预共享密钥。认证信息包含身份ID，字符串，随机数等。关掉一侧的认证。
3.43    产品部署中重要资源的变更没有记录日志属于安全红线问题。
3.44    所有的配置命令执行日志需要保存在远程日志服务器上。
3.45    提供适用于各个产品线的CCB加密组件，实现组件化的模块设计，产品代码维护也更加简单：经济适用原则。
3.47    命令行查询操作不会对系统产生影响，所以不强制要求记录日志。
3.48    数字签名可以同时提供身份认证，数据完整性以及抵赖服务。
3.49    预共享密钥不能同时用于认证和完整性保护。
3.50    分组密码算法中某些算法，如GCM，CCM可以同时提供加密和消息认证服务。
3.51    缓冲区溢出：启动编译选项和操作系统加固。
3.52    命令注入：用户的输入进行白名单判断。
3.53    SQL注入：预编译，白名单，检查数据长度，使用存储过程，检查数据类型。
3.54    暴力破解：登录延时，锁定，验证码。
3.55    仿冒：出厂默认密钥不同，从而避免批量破解。
3.56    嗅探：避免低版本密钥。
3.57    钓鱼攻击：提升人员网络安全意识，降低欺骗，钓鱼攻击的风险。
3.58    处理风险的4个方法：消减，规避，转移，接受。
3.59    人机账号口令有效期3个月，机机账号有效期6个月，口令用PBKDF2算法保存。
3.60    对称加密至少使用CBC模式的AES128算法加密，IV每次都随机生成。
3.61    SSH登录：禁止telnet，禁止root，使用SSHv2，验证服务端，公钥客户端。
3.62    信任边界类型：网络边界（internet，DMZ，trust域），主机边界（一个主机设备或者主机群为主体设置边界），外部接口（开放API接口，用户操作界面），内部接口（不同域之间交互接口）。
3.63    数据控制者决定了个人数据处理的目的，决定了个人数据处理的方式。数据处理者代表数据的控制者，并按照数据控制者的要求处理个人数据。
3.64    Nmap扫描是用于验证端口开放情况，而不是用于通信矩阵写作。
3.65    需要使用安全随机数的是：CBC加密用的初始向量IV，会话ID，盐值。
3.66    SSL/TLS加密套件中，推荐使用的加密套件是：TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
3.67    敏感个人数据的是：种族血统，宗教或哲学信仰，健康状况，身份证号，社保号，银行卡号。
3.68    HttpOnly属性可以禁止JS脚本读取cookie。
3.69    会话劫持防范方法：使用加密通道，B/S使用httponly属性。
3.70    通过加密通道传输会话标识，使用cookie的httponly属性可以有效防范会话劫持 （说法错误）
3.71    cookie是动态生成的，不是在代码中的。
3.72    ASTRIDE High Level威胁分析建模过程是：选取整合架构图，绘制信任边界，识别关键元素，威胁问卷分析，制定消减措施，架构安全设计方案。【选取结构图，----》最终得到架构设计方案】
3.73    LowLevel威胁建模流程：绘制数据流图->威胁分析->风险评估->制定消减措施->产品响应
3.74    日志中不能打印：明文密码，加密后的密码。
3.75    安全随机数生成器：Unix的/dev/random，OpenSSL的EAND bytes，Windows的CyptGenRandom，JDK的java.security.SecureRandom。
3.84    ADCP必选审视项：测试报告中与可信产品定义相关的测试闭环验收结果；可信要求规划的开发落地质量（缺陷率和遗留缺陷等）

3.21    （单选）业界威胁建模方法主要的类型不包括（ ）
A. 以威胁为中心
B. 以攻击者为中心
C. 以软件为中心
D. 以资产为中心
答案：A
解析：
B. 是攻击树，由英国政府、安全机构在用，输出：列举系统可能的攻击
C.以软件为中心，STRIDE
D. 是TVRA，由爱立信在用，输出：列举资产的弱点和风险


3.22    （单选）对于TVRA威胁建模方法，说法最正确的是（）
A. 识别资产的目的是计算资产的价值
B. 识别资产的目的是保证保护资产的措施不高于资产价值本身
C. 识别资产的目的是对最关键的资产进行保护
D. 识别资产的目的是对资产进行分级保护
选D。
解析：HiSEC Insight（CIS）创建资产时要求选定资产价值，其实就是一种分级保护策略，未来需要进一步按照分级保护的目的在客户层面改进易用性。
TVRA识别资产的目的是对资产进行分级保护。
FMEA，失效模式与影响分析，是一种自下而上的方法，用于分析一个系统设计或制造过程，以评估潜在失效和影响。

3.79    可信系统设计需要考虑哪些方面？
A可信架构能力模型
B 产品领域威胁分析
C 可信架构设计原则定义
D 可信设计模式
参考答案：ABCD


3.82    哪些角色需要掌握可信设计理论和方法？
A  系统工程师
B  解决方案SA
C  SE
D 架构师
参考答案：ABCD


3.85    如下哪些是ADCP必选审视项？
A 产品在上市阶段在可信要求上是否做到该行业标杆
B测试报告中与可信产品定义相关的测试闭环验收结果
C 可信要求规划的开发落地质量（缺陷率和遗留缺陷等）
D与可信相关的目标和资源投入
选BC

3.87    如下哪些是Charter/CDCP必选审视项？
A 产品在上市阶段在可信要求上是否做到该行业标杆
B 业务场景/威胁分析的要求，韧性要求，认证及等级要求
C 可信产品定义的需求，代码重构和技术债务的需求和工作量
D 可信带来的代码重构和技术债务
选ABD


3.88    如下哪些是PDCP必选审视项？
A 可信产品定义的需求，代码重构和技术债务的需求和工作量
B 业务场景/威胁分析的要求，韧性要求，认证及等级要求
C 产品在上市阶段在可信要求上是否做到该行业标杆
D 与可信相关的目标和资源投入
选ACD，威胁分析是CDCP


3.89    如下哪些行为是需要在产品定义阶段完成的？
A识别产品网络环境和业务场景及变化
B完成威胁和攻击路径分析
C定义本领域可信架构设计原则和设计模式
D定义产品认证及等级要求
选ABD。


3：用于描述两个对象之间消息交互的 UML 图是：()
A：用例图
B：类图
C：顺序图
D：组件图
选C，消息交互是顺序图。

4：用例图中的 Include 关系是对应的 UML 四个关系中哪一种关系：()
A：关联
B：泛化
C：实现
D：依赖
选D。




3：以下属于动态模型图的是：()
A：类图
B：顺序图
C：部署图
D：状态图
选BD。


4：类图的 6 种关系中，比聚合关系强的是：()
A：依赖
B：泛化
C：组合
D：关联
选BC。 泛化（继承）= 实现 >组合 》 聚合 》 关联 》 依赖

5：以下表达式方式正确的是：()选AD，第一个是组合，第二个是继承泛化，第三个是关联，第四个是依赖
依赖是虚箭头。实现是虚三角。其他都是实线。
C项关联应该是用实箭头。
B项动物到老虎应该是实现，用虚线三角，老虎到动物是泛化，用实三角。
A项是组合，用实菱形。
思考：组合和聚合的区分？
组合，整体与局部
聚合，整体与个体


6：类图中以下哪些关系是表示整体与局部的关系：()
A：关联
B：聚合
C：泛化
D：组合
个人认为选D。

总结式梳理：
#####可信设计#####
1：已经拒绝的需求，在设计时也需要考虑，因为未来可能会被采纳；  注意只是加以考虑，如果是真正实施设计的话，就是错的，过于关注未来了。
2：A 类红线偏重于政治和法律方面的考虑，B 类红线问题注重的是技术层面的安全性。
3：机机接口防暴力破解，不能仅使用 IP 白名单，因为 IP 可以被仿冒。
4：登录失败后，不能提示“账户停用，密码错误，无效的用户 ID”，因为这个会造成信息
泄漏。
5：敏感信息不可以打印在日志中，敏感信息包含：会话 token 信息，SessionId 信息，密
码明文信息。用户名不是敏感信息。
6：系统中存在一组账号写死在源码中，相关资料未做说明属于未公开接口问题。
7：产品应该规划独立的北向接口用户，原则上人机账号不能用于机机接口，机机账号不允
许具备登录人机界面的能力，人机账号和机机账号不能是相同的账号。
8：数据流信息泄漏会破坏系统的机密性。
9：系统中的漏洞越多并不意味着风险越大，需要根据安全风险定级来确认风险。
10：消减措施应基于风险来给出。
11：测试阶段不会引入安全风险。
12：CSRF 防御：验证 HTTP Refer 字段，请求中添加 Token，HTTP 中自定义属性并验证。
13：ASTRIDE 面向软件，攻击树面向攻击，TVRA 面向资产。
14：FMEA，失效模式与影响分析，是一种自下而上的方法，用于分析一个系统设计或制造
过程，以评估潜在失效和影响。潜在故障
15：证书指纹算法使用 SHA1 不是安全红线问题。
16：TVRA 识别资产的目的是对资产进行分级保护。
17：PBKDF2 是标准的密钥派生函数
18：禁止 MD5 应用在参与生成“数字签名、口令加密保存”这两种场景（HMAC-MD5 例
外），禁止 SHA1 应用在参与生成“数字签名”的场景。
19：在有实际需求时，允许产品使用不安全的协议，但必须同时支持安全的协议。
20：使用 Coverity 扫描，分析实际风险，为“高”的漏洞（CVSS 7 分及以上），必须进行
解决或规避。
21：漏洞扫描测试越早开展越好（如 TR4A），避免没有足够时间分析处理漏洞。公司指定
使用 Nessus 进行扫描。
22：CRC 不能用于软件完整性校验。
23：嵌入式软件包也应该做防病毒检查。
24：Web 应用的最终用户 portal 和管理 portal 也同样需要考虑隔离，如部署在不同的物
理服务器上；如果是合设，考虑通过端口隔离。
25：产品 GPI 资料、研发设计文档、第三方资料等都可以作为受限公开资料。
26：精确位置指经纬度、GPS 等，基站定位属于一般位置信息。
27：对称加密：推荐 AES，不推荐 RC4，3DES。哈希算法：推荐 SHA256，不推荐 SHA1，
MD5。非对称加密：RSA。密钥交换：DH, ECDH。
28：禁止使用 SSL2.0，SSL3.0 协议，TLS1.0 协议仅可遗留使用，推荐使用 TLS1.1, TLS1.2
版本。
29：对称加密算法运算速度快，密钥长度短，密文长度少，安全性容易证明，缺点是：密钥
分发困难，不可用于数字签名。
30：非对称加密算法密钥分发容易，可以用于数字签名，缺点是：运算慢，密文长度剧烈增
长，密钥长度长，安全性不容易证明。
31：中间人攻击：双向认证，数字证书认证，公私钥对认证。
32：重放攻击：引入时间戳，序列号，随机数等时变参数。
33：反射攻击：双方采用不同的预共享密钥。认证信息包含身份 ID，字符串，随机数等。
关掉一侧的认证。
34：权限提升的消减措施：权限最小化，沙箱。
35：ASTRIDE 不能发现代码中的安全漏洞。
36：函数行数不超过 50 行，函数参数不超过 5 个。
37：产品部署中重要资源的变更没有记录日志属于安全红线问题。
38：所有的配置命令执行日志需要保存在远程日志服务器上。
39：提供适用于各个产品线的 CCB 加密组件，实现组件化的模块设计，产品代码维护也更
加简单：经济适用原则。
40：威胁不会因为系统进行了防护就消失。
41：命令行查询操作不会对系统产生影响，所以不强制要求记录日志。
42：数字签名可以同时提供身份认证，数据完整性以及抵赖服务。
43：预共享密钥不能同时用于认证和完整性保护。
44：分组密码算法中某些算法，如 GCM，CCM 可以同时提供加密和消息认证服务。
45：缓冲区溢出：启动编译选项和操作系统加固。
46：命令注入：用户的输入进行白名单判断。
47：SQL 注入：预编译，白名单，检查数据长度，使用存储过程，检查数据类型。
48：暴力破解：登录延时，锁定，验证码。
49：仿冒：出厂默认密钥不同，从而避免批量破解。
50：嗅探：避免低版本密钥。
51：钓鱼攻击：提升人员网络安全意识，降低欺骗，钓鱼攻击的风险。
52：处理风险的 4 个方法：消减，规避，转移，接受。
53：人机账号口令有效期 3 个月，机机账号有效期 6 个月，口令用 PBKDF2 算法保存。
54：至少使用 CBC 模式的 AES128 算法加密，IV 每次都随机生成。
55：SSH 登录：禁止 telnet，禁止 root，使用 SSHv2，验证服务端，公钥客户端。
56：信任边界类型：网络边界（internet，DMZ，trust 域），主机边界（一个主机设备或者主机群为主体设置边界），外部接口（开放 API 接口，用户操作界面），内部接口（不同域之间交互接口）。
57：数据控制者决定了个人数据处理的目的，决定了个人数据处理的方式。数据处理着代表
数据的控制者，并按照数据控制者的要求处理个人数据。
58：Nmap 扫描是用于验证端口开放情况，而不是用于通信矩阵写作。
59：需要使用安全随机数的是：CBC 加密用的初始向量 IV，会话 ID，盐值。
60 ： SSL/TLS 加 密 套 件 中 ， 推 荐 使 用 的 加 密 套 件 是 ：
TLS_DHE_RSA_WITH_AES_256_GCM_SHA384
61：敏感个人数据的是：种族血统，宗教或哲学信仰，健康状况，身份证号，社保号，银行
卡号。
62：HttpOnly 属性可以禁止 JS 脚本读取 cookie。
63：会话劫持防范方法：使用加密通道，B/S 使用 httponly 属性。
64：cookie 是动态生成的，不是在代码中的。
65：ASTRIDE High Level 威胁分析建模过程是：选取整合架构图，绘制信任边界，识别关键元素，威胁问卷分析，制定消减措施，架构安全设计方案。
66：日志中不能打印：明文密码，加密后的密码。
67：安全随机数生成器：Unix 的/dev/random，OpenSSL 的 EAND bytes，Windows 的CyptGenRandom，JDK 的 java.security.SecureRandom。
68：socket 绑定 0.0.0.0 不属于默认安全要求。
69：指纹认证属于：他就是这个人（something you are）。
70：篡改的消减措施是：数字签名。
71：STRIDE 威胁建模方法关键步骤不包括：识别攻击者。
72：数字信封：数据传输使用对称加密密钥，密钥传输使用非对称算法的公钥。
73：敏感信息包括：密钥，密码，高影响的个人数据，SessionID
74：敏感个人数据包括：身份证号，社保号，银行卡号，种族血统，宗教信仰，健康状态
75：违反 CSEC Golden Rules 的是：考虑易用性设备管理提供”记住密码“的功能，为保证设备开局免软调协议缺省关闭认证。为了便于维测，将操作日志上传到远程服务器。
76：威胁库的建设主要分析威胁对业务的影响，已有的消减措施，攻击的可能性，并识别系统存在的缺陷。
77：STRIDE 需要先绘制数据/业务流图，在针对其中元素对应的威胁逐个分析，找到缺陷
和消减措施。
78：STRIDE 威胁分析需要逆向思维（像攻击者一样思考）和开放式的头脑风暴，熟悉常见的攻击思路。
79：安全设计原则有：失败-默认安全原则，权限分离原则，最小权限原则。
80：威胁不会因为系统进行了防护就消失，是一种破坏系统安全的因素，会随环境的改变而
改变。
81：防止权限提升的措施有：沙箱隔离，权限最小化。
82：最小公共化原则：共享内存最小化。管理面，用户面和控制面的协议绑定在各自的 IP
地址上，避免多个对象共享同一资源。网站架构设计时使用负载均衡技术分散到下属的多台
主机上。
83：老的不安全，不兼容时，老的还是保持不安全，告知用户。兼容时，直接替换。
84：三权分立采用的设计原则：权限分离原则。
85：会话认证前的攻击：基于 IP 的攻击，基于应用层的协议攻击，DDOS 攻击。（会话标
识可猜测攻击不是会话认证前的攻击）。
86：数字信封采用接收方非对称的公钥进行加密，实际的传输数据使用对称密钥加密。
87：STRIDE 威胁建模不能识别代码风险，找到代码的缺陷。
88：使用弱口令或者其他方式盗用密码登录，登录后修改用户订单等信息属于 spoofing 威
胁。
89：FEMA：潜在故障模式，功能影响。
90：符合权限最小化的要求：禁用 root 用户的远程访问。
91：当数据流穿越不同的信任级别或区域时，就存在信任边界。
92：未公开的接口：隐藏命令或参数，可绕过系统认证的访问接口，隐藏账号，隐藏快捷键。
93：外部交互方存在的威胁：spoofing，repudiation
94：安全设计中：考虑建立逃生策略，避免因为证书加载失败，错误配置引起通信中断。选
择一种合适的安全传输协议。
95：基于策略的访问控制模式中，一般包含：策略实施点 PEP，策略信息点 PIP，策略决策
点 PDP，策略管理点 PAP。IDEA
96：对敏感数据加密时，被禁止的方法有：自研的加密算法。通过变形/字符移位等方
式执行算法。通过编码方式 Base64 实现数据加密等。（用 3DES k1!=k2!=k3 算法是 OK
的）
97：防范CSRF 攻击的主流方法是：隐藏域token
98：会话固定攻击的避免方法：认证通过后更换会话标志，提供会话超时的清除机制，登录
后才能访问的界面必须提供主动退出选项。
99：出于业务和商业需要，在用户授权下我们可以适当的搜集用户的浏览信息进行大数据分
析，以便推送一些相关产品信息。
100：默认设置一个维护账户，口令为 *****，支持修改且在文档中声明，这个不
属于未公开接口。
101：认证方式包含：他所知道的，他就是这个人，他所持有的。
102：破坏系统可用性的威胁：处理过程拒绝服务，数据流拒绝服务。
103：口令单向哈希保存时使用 PBKDF2 算法，增加盐值和迭代次数，可以抵抗彩虹表和暴力攻击。
104：不属于被动攻击的是：嗅探
105：STRIDE 威胁建模已经落到产品的 IPD 开发流程中了。
106：计算机应用为了追求性能，经常使用缓存机制，在通过第一次安全检查后缓存检查结
果，后续不再经过安全机制的验证，直接引用缓存机制中的数据，这种做法违反了完全仲裁
原则
107：数字签名在同时进行加密和签名是：应该先签名，后加密。
108：安全隐私保护设计：在安全敏感市场，不允许产品出于故障定位目的进行用户精确位
置定位。产品在个人数据的采集/处理时提供安全保护机制。
109：匿名化是一种对数据不可逆改变的过程，处理后的个人数据将无法直接或间接的还原，
已经不再是个人数据，因此匿名化后的数据不受个人数据保护法律法规的限制
110：非自研操作系统中的漏洞同样需要产品发布前解决
111：https 加密传输，整个流程涉及到的加密方式包含对称加密和非对称加密
112：不需要双向认证的场景：Web 服务器与转发路由器
113：设备的默认设置应该尽可能的安全，及时这样可能会牺牲易用性

错误描述
错误的描述 1：基于策略的访问控制模式中，不能再应用基于角色的访问控制模式。
错误的描述 2：识别威胁是发现组件或进程存在的威胁，他可能是恶意的，威胁就是漏洞。
错误的描述 3：GDPR 对欧盟外的实体没有任何约束。
错误的描述 4：用户不可配置日志的存储时间。
错误的描述 5：通过加密通道传输会话标识，使用 cookie 的 httponly 属性可以有效防范会话劫持
错误的描述 6：安全架构师设计阶段包含 astride low level 威胁分析活动
错误的描述 7：口令验证时，无验证码的安全风险一定很高
错误的描述 8：会话 id 可以通过 url 传递（id不能从url传递）
错误的描述 9：允许对某些特别用户进行特殊处理，如对低级权限的管理员的解锁可以不记录日志
错误的描述 10：处理个人数据应该有具体、明确、合法的目的，如果业务需要，可以进行与这些目的不一致的处理
错误的描述 12：假名化是一种数据保护的手段（如偏移、置换、哈希等），假名化数据不是个人数据，因此假名化后的数据不受个人数据保护法律法规的限制
错误的描述 13：系统支持的用户同时建立的会话数越多越好
错误的描述 14：密码信息和用户信息经过简单的转码操作后再记录在数据库中，当需要认证确认是，再用简单的转码操作来确认输入的正确性。
错误的描述 15：用户不可配置日志存储的时间
错误的描述 16：威胁取决于系统有多少安全漏洞

5	设计模式习题
________________________________________

其他练习参考：https://blog.csdn.net/sanjiaozhen/article/details/48850701

优先使用 组合而不是继承 ，因为继承会造成严重的依赖关系，另外继承会破坏封装性，将父类的实现细节暴露给子类。

 动态增加过滤条件，用来实现关键字过滤采用那种模式： 责任链 。（比如 java  的异常处理机制）

 不改变第三方库的代码，实现该库功能的对接： 桥接模式和适配器模式

  存在继承的情况下，方法向超类方向集中，数据向子类方向集中 。

 设计模式的思想根源是 开闭基本原则 的宏观运用

访问者模式 可达到一个 被访问者 动态添加新的操作而无需做其他的修改的效果，适合处理过程可扩展的场景（比如购物车设计）。

 模板 方法模式使用模板以避免创建子类，不一定提供工厂方法的默认实现。

 桥接模式将抽象部分与它的实现部分分离，使他们都可以独立的变化。（比如大中小 3 种型号的画笔，绘制 5种颜色，模拟画笔的使用）

 一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖，修改自己的注册信息，修改自己帖子的功能，而游客只能看到别人发的帖子，其他的权限，可以使用 代理模式

设计 模式的基本要素有（名字  ），（意图  ），（问题  ），（  解决方案  ），（参与者与协作者  ），（实现），（一般性结构）。

 创立型模式的根本意图是要把（对象的 创建 ）和（ 使用

工厂模式分为( 简单工厂),( 工厂方法),( 抽象工厂) 三种类型 

 门面模式是 是( 迪米特)法则的典型应用。

 MVC  模型的基本工作原理是基于( 观察者) 模式，实现是基于（ 命令）模式
看MV是观察，C是command命令模式

1.1       Java.lang.reflect.Proxy用了（）
A单例模式
B装饰器模式
C代理模式
D反射
选C

2.59    软件启动的时候会远程读取数据库，导致启动过程缓慢，为了优化增加一个数据代替类属于：（）
A 代理模式；
B 组合模式
C 外观模式
D 桥接模式
选A。

2.60    （单选）某个系统执行一个动作需要调用数据库查询，比较慢，现在改造成加个缓存模块，然后先调用这个缓存模块，异步从数据库中刷新数据到缓存中，这种做法使用了哪种设计模式 （）
A．代理
B．桥接
C. 适配器
D．享元
选A。启动慢问题，选代理模式。

2.62    下面关于模板方法正确的是：
A. 操作的整体步骤固定，其中小部分容易变动的场景
B. 一个请求操作需要多个对象处理时
C. 为了减少对象创建的数量，降低内存占用和提高性能
D. 各子类中公共的行为需要被提取出来并集中到一个公共的父类中以避免代码重复。
选AD。C是享元模式

2.63    享元模式，复用变化少的对象
对于享元模式，下列说法正确的是（）选ACD。内部状态固化是错的，外部状态才是固化的。



 2.43    对于违反里氏替换原则的两个类A和B，可以采用的候选解决方案中，错误的是 ().
A. 尽量将一些需要扩展的类或者存在变化的类设计为抽象类或者接口，并将其作为基类，在程序中尽量使用基类对象进行编程
B. 创建一个新的抽象类C，作为两个具体类的超类，将A和B共同的行为移动到C中，从而解决A和B行为不完全一致的问题
C. 将B到A的继承关系改成组合关系
D. 区分是“Is-a”还是“Has-a”。如果是Is-a，可以使用继承关系，如果是Has-a,应该改成组合或聚合关系
选A。

1.  面向对象设计的基本原则中的开闭原则指出软件要对扩展开放，对修改关闭。违反开闭原则可能造成的坏味道有（）
A. 基本类型偏执(Primitive Obsession)
B. 散弹式修改(Shotgun Surgery)
C. 过长参数列表(Long Parameter List)
D. 发散式变化(Divergent Change)
选BD。

【来自：必备学习资料】
5：设计模式的两大主题是：()
A：系统的维护与开发。
B：对象组合和类的继承。
C：系统架构与系统开发
D：系统复用与系统扩展
选D。解析：使用设计模式是为了可重用代码、让代码更容易被他人道理解、保证代码可靠性。


6：以下哪条不属于 SOLID 原则：()
A：依赖倒置
B：里氏替换原则
C：最小知识原则
D：开闭原则
选C。依赖是Depend，理士替换是L，开闭原则是Open
解析：设计模式的六大原则有：
Single Responsibility Principle：单一职责原则
Open Closed Principle：开闭原则
Liskov Substitution Principle：里氏替换原则
Interface Segregation Principle：接口隔离原则
Dependence Inversion Principle：依赖倒置原则
把这些原则的首字母联合起来就是 SOLID （solid，稳定的），其代
表的含义就是这六个原则结合使用的好处：建立稳定、灵活、健壮的设计
Law of Demeter：迪米特法则也就是最小知识原则，不算在SOLID里。


7：将一个类的接口转换成客户希望的另一个接口，是对那种模式的描述：()
A：桥接模式
B：适配器模式
C：中介者模式
D：策略模式
选B。结构改造以适配新的需求，是适配器模式

8：( )定义了一个高层接口，这个接口使得这一子系统更加容易使用：()
A：适配器模式
B：桥接模式
C：策略模式
D：外观模式
选D，外观模式，对外只一个接口，把复杂留给自己


9：当我们想创建一个具体的对象而又不希望指定具体的类时，可以使用( )模式：()
A：创建型
B：结构性
C：行为型
D：以上都可以
选A，比如工厂模式、抽象模式这些都是不指定具体类的创建型设计模式


10：应用设计模式的一个优点是：()
A：程序易于理解。
B：适应需求变化。
C：减少代码量。
D：简化软件系统设计。
选B，需求变化可迅速复用和扩展


11：定义一系列算法，把它们一个个封装起来，并使他们可相互替换，这是对哪种模式的描
述：()
A：观察者模式
B：桥接模式
C：策略模式
D：适配器模式
选C，22. Strategy（策略）：使用接口即使用 strategy，用于隔离变化。一个接口一个算法。桥接是使用关联代替继承，解决类多维度的扩展导致的类爆炸的问题


7：以下属于创建型模式的有：()
A：适配器模式
B：单例模式
C：工厂模式
D：观察者模式
选BC，外观模式和A是结构型，责任链和备忘录和D是行为模式。



下列属于访问控制类的安全设计模式的有
A 代理控制设计模式
B 控制授权模式
C 引用监视器模式
D API 控制错误模式
选 ABCD


设计模式扩展思考题：
7.结构型模式有什么特点？
8. 可以分为哪两类，二者有什么区别？
9.适配器模式有几种实现方式，分别是怎么实现的，有什么优缺点？
10.外观模式是如何实现的，有什么优缺点？
11.外观模式和适配器模式有什么差别？
12. 行为型模式用于描述多个类或对象之间，怎样相互协作共同完成单个对象都无法单独
完成的任务，它涉及算法与对象间职责的分配。能体现出程序在运行时复杂的流程控制。
13. 责任链模式和观察者模式都降低了对象之间的耦合关系，增强了系统的可扩展性。这
两种模式完全解耦了吗？
14. 行为型模式分为类行为型模式和对象行为型模式，前者采用继承机制来在类间分派行
为，后者采用组合或聚合在对象间分配行为。
（考题）15. 工厂模式，适配器模式，责任链模式和观察者模式属于什么类型的模式？
答案：适配器模式，责任链模式，观察者模式都是行为模式，工厂模式是结构型模式




【来自真题一】
1、设计模式一般用来解决什么样的问题( )
A.同一问题的不同表相 B 不同问题的同一表相
C.不同问题的不同表相 D.以上都不是
选A


2、下列属于面向对象基本原则的是(  )
A.继承 B.封装 C.里氏代换 D 都不是
选C，解析：封装，继承，多态是面向对象的 3 大基本特性，是理解面向对象设计原则 SOLID 的基础。


3、Open-Close 原则的含义是一个软件实体(  )
A.应当对扩展开放，对修改关闭.
B.应当对修改开放，对扩展关闭
C.应当对继承开放，对修改关闭
D.以上都不对
选A。可以扩展，不能修改。


4、当我们想创建一个具体的对象而又不希望指定具体的类时，可以使用（  ）模式。
A.创建型 B.结构型 C 行为型 D.以上都可以
选A。


5、要依赖于抽象，不要依赖于具体。即针对接口编程，不要针对实现编程,是(  )的表述
A.开-闭原则
B.接口隔离原则
C.里氏代换原则
D.依赖倒置原则
选D，解析：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。抽象和细节统一都要依赖于抽象。


6、依据设计模式思想，程序开发中应优先使用的是(  )关系实现复用。
A, 委派 B.继承 C 创建 D.以上都不对
选A。复用方式：继承和组合聚合（组合委派）


8、单子模式中,两个基本要点(  )和单子类自己提供单例
A .构造函数私有 B.唯一实例
C.静态工厂方法 D.以上都不对
选AB。


9、下列模式中,属于行为模式的是( )
A.工厂模式 B 观察者 C 适配器 以上都是
选B。解析：A 工厂模式是创建型，C 是结构性，B 是行为型


10、“不要和陌生人说话” 是(  )原则的通俗表述
A.接口隔离
B.里氏代换
C.依赖倒转
D.迪米特
选D，最小知识，最少知道，一个对象应对其他对象尽可能少的了解



11、构造者的的退化模式是通过合并（ ）角色完成退化的。
A.抽象产品 B 产品 C 创建者 D 使用者
选C，


12、单子（单例，单态）模式类图结构如下：
下列论述中，关于”0..1”表述的不正确的是(  )
A.1 表示,一个单例类中,最多可以有一个实例.
B.”0..1”表示单例类中有不多于一个的实例
C.0 表示单例类中可以没有任何实例
D.0 表示单例类可以提供其他非自身的实例
选D


13、对象适配器模式是（  ）原则的典型应用。
A.合成聚合复用原则
B.里式代换原则
C.依赖倒转原则
D.迪米特法则
选A。修改已有接口，以适配新的需求，基于复用已有的东西上，合成聚合。


14、静态工厂的核心角色是（）
A.抽象产品 B.具体产品 C.静态工厂 D.消费者
选A。


15、下列关于静态工厂与工厂方法表述错误的是：（）
A.两者都满足开闭原则：静态工厂以 if else 方式创建对象，增加需求的时候会修改源代码
B.静态工厂对具体产品的创建类别和创建时机的判断是混和在一起的，这点在工厂方法中
C.不能形成静态工厂的继承结构
D.在工厂方法模式中，对于存在继承等级结构的产品树，产品的创建是通过相应等级结构
的工厂创建的。
选A。修改源代码不符合开闭原则。


16、在观察者模式中，表述错误的是（ ）
A.观察者角色的更新是被动的。
B.被观察者可以通知观察者进行更新
C.观察者可以改变被观察者的状态，再由被观察者通知所有观察者依据被观察者的状态进
行。
D.以上表述全部错误。
选C。


17.对于违反里式代换原则的两个类，可以采用的候选解决方案错误的是：（ ）
A.创建一个新的抽象类 C,作为两个具体类的超类，将 A 和 B 共同的行为移动到 C 中，从
而解决 A 和 B 行为不完全一致的问题。
B.将 B 到 A 的继承关系改组成委派关系。
C.区分是“IS-a”还是”Has－a”。如果是“Is-a”，可以使用继承关系，如果是”Has
－a”应该改成委派关系
D.以上方案错误
选D。其中ABC是正确的。

18.对象组合的优点表述不当的是（  ）
A. 容器类仅能通过被包含对象的接口来对其进行访问。
B. “黑盒”复用，封装性好，因为被包含对象的内部细节对外是不可见。
C. 通过获取指向其它的具有相同类型的对象引用，
可以在运行期间动态地定义（对象的）组合
D.造成极其严重的依赖关系。
选D. 对象组合的优点，不会造成严重依赖关系。

19.关于继承表述错误的是：（  ）
A.继承是一种通过扩展一个已有对象的实现，从而获得新功能的复用方法。
B.泛化类（超类）可以显式地捕获那些公共的属性和方法。特殊类（子类）则通过附加属性和方法来进行实现的扩展。
C.破坏了封装性，因为这会将父类的实现细节暴露给子类。
D.继承本质上是“白盒复用”，对父类的修改，不会影响到子类。
选D。对父类的修改会影响子类，因为子类是继承自父类的。


20.对于依赖倒转的表述错误的是（  ）
A. 依赖于抽象而不依赖于具体，也就是针对接口编程。
B. 依赖倒转的接口并非语法意义上的接口，而是，一个类对其他对象进行调用时，所知道
的方法集合。
C. 从选项 B 的角度论述，一个对象可以有多个接口。
D. 实现了同一接口的对象，可以在运行期间，顺利地进行替换。而且不必知道所示用的对
象是那个实现类的实例。
E. 此题没有正确答案。
选E。该题逻辑较绕。A-D表述全对，仅从A-D来看，没有正确答案。所以E的表述也正确，而题目要求选择表述错误的，选了E，就相当于E的表述错误，就是一种逻辑悖论。
理由：闭着眼睛选E就行，20题肯定有正确答案，所以E的表述错误，选它，而A-D表述都正确。

6	
需求分析管理习题
________________________________________



15：对软件需求的分类，以下理解错误的是：( )
A：质量需求也应属于软件需求，在需求分析时需要考虑
B：系统必须提供版本间兼容的北向接口属于版本管理范畴，不应该纳入软件需求进行分析
C：软件需求可以分为功能性需求，质量需求和约束
D：不明确的功能性需求，在需求分析时不需要细化
选BD，需求分析干的就是接口分析，将功能需求尽量细化明确


16：需求分析输出的质量准则包括完整性，正确性，可验证性，一致性；其中正确性包括如
下哪些准则：()
A：正确的，相关涉众确认了需求的正确性，并且系统完整地实现了文档化的需求
B：最新的，需求反应了系统当前的实现状态
C：无歧义的，需求的文档化描述只允许一种合理的解释
D：原子的，每个需求描述的是单一，内聚的事实。
选ABCD


17：软件需求管理是软件项目开发过程中控制和维持需求约定的活动，以下哪些属于需求管理活动：()
A：需求发现
B：需求变更控制
C：版本控制
D：需求跟踪
选BCD，两个控制两个跟踪，变更控制，版本控制，状态跟踪，需求跟踪。需求发现属于需求分析里的，分析完需求以及解决方案后，开始实施，这时才有需求管理。



1.（判断）已经拒绝的需求，在设计时也需要考虑，因为未来可能会被采纳。（）
A.正确 B.错误
答案：A
解析：要看这个需求是什么样的，如果是因为优先级问题拒绝的需求，那是要考虑未来兼
容和扩展性的。如果该需求就是永远不会采纳的，而且会破坏当前架构逻辑的，那肯定不
应该考虑，这也是所谓的夸夸其谈的未来性坏味道。


需求排序不应该考虑以下哪个因素（）
A 需求约束
B 实现成本
C 与战略目标符合度
D 需求价值
选 A，在实现需求时才考虑约束


如下需求价值排序方法中哪个不属于定性分析方法：
A KANO 模型
B 波士顿矩阵
C 价值复杂矩阵
D 四象限法则
选A，定性分析方法常见只有BCD。A是定量分析


需求分析关键步骤包含如下哪些？
A 需求澄清
B 竞争分析
C 确定交付范围
D 需求检查
选ABCD。


关于需求与问题的界定，如下哪些说法是正确的？
A 新产品/版本相对于老产品/版本的特性、设计等遗漏，应属于问题
B 已引发网上事故的设计和实现，属于问题
C 新产品/版本相对于老产品/版本的性能，在相同场景下出现下降，应属于问题
D 属于公司/产品线/产品等 DFx 基线的需求，当前版本不具备，应属于需求
选ABC。D项应该是问题，需求已经定义清楚了，但当前版本不具备，是需要解决的问题。


如下哪些是 Goal-Oriented  目标导向需求分析方法的图元？
A Performance 性能
B Goal 目标
C Requirement 需求
D Obstacle 障碍
选BCD，首先是需求必须有R，然后有GO有，实现的响应目标，以及对应的障碍


需求的图形化表示可以帮助对系统需求的理解，检测不一致性、模糊性、错误和遗漏，如下哪些可用作需求的图形化表示的模型 （）
A 数据流图
B 实体关系图
C 对话图
D 控制图
选ABC， 实体关系、数据流、对话，在实现时才有控制流。



需求有哪些来源 
A 用户调研
B 产品规划
C 竞品分析
D 个人爱好
选ABC
.
以下哪个文档属于需求分析交付件 
A 架构设计文档
B 软件需求规格说明
C 使用实例文档
D 项目范围文档
选B。需求分析后会输出需求规格说明作为对功能的量化，ACD是实现过程或者实现完毕的输出结果。


2（单选）在面向团队进行需求收集时，下列需求收集方法的叙述不恰当的是：()
A：举行团队需求收集会议，会议由软件工程师、客户和其他利益相关者共同举办和参加
B：拟定一个会议议程，与会者围绕需求要点，畅所欲言
C：会议提倡自由发言，不需要特意控制会议的进度
D：会议目的是为了识别问题，提出解决方案的要点，初步刻画解决方案中的需求问题
选C。

6（多选）如下安全相关的文档，需要在 TR1 阶段输出的有：
A 需求敏感特性自检
B 安全性威胁分析及需求说明书
C 红线解决方案落地自检表
D 安全需求分解分配表
选AB。需求特性自检和需求说明。没有D。


7（多选）如下哪些行为是需要在产品定义阶段完成的？
A 识别产品网络环境和业务场景及变化
B 完成威胁和攻击路径分析
C 定义产品认证及等级要求
D 定义本领域可信架构设计原则和设计模式
选ABC。 设计模式也是在实现的时候选择的，而非设计。

1.10  需求规格说明书的内容不应包括如下哪项：
A 用户界面的运行环境
B 软件性能
C 主要功能
D 算法的详细实现过程
选D


受 限公开资料可以通过以下哪几种形式提供： ()
A：GPI 资料
B：CPI 资料 // 完全公开资料
C：设计文档
D：第三方资料
选ACD。主要看受限公开，与B完全公开相区分。没有CPI


在 需求分析活动中，下面哪种做法容易引起某环节信
息传递缺失或需求理解出现偏差（）
A. 将需求以测试用例的方式呈现，并尽早验证
B. SE 独立进行需求分析，并严格按照流程输出需求分析文档，开发人员根据此文档进行下
一步设计和开发
C. 客户、MKT、SE、TSE 等一起参与需求的分析制定，并通过实例场景来说明
D. 采用 GWT（Given-When-Then），数据表格等格式来描述需求的场景或实例
选B，不能闭门造车。


常用的需求分析方法：
A 客户场景分析
B 基于Use Case 分析
C DFX分析
D STRIDE威胁分析
选ABCD。

以下哪个组织负责评审接纳需求 
A TMG
B RAT
C CCB
D DRB
选B。RAT，Requirement Analysis Team。分析：
DRB 全称：Design Review Board 设计评审委员会（在平台和产品设计架构前开启的评
审）RAT 是 SPDT 任命的需求管理组织，是 SPDT 最高需求决策机构，周期执行重要决
策，对 CCB 评估接纳的需求进行审核，对 CCB 拒绝、无法答复的需求进行处理
CCB 全称 ：Change Control Board 变更控制委员会（软件工程行业里决定实施或拒绝
针对某个项目的变更请求的专家团，通常由项目干系人或干系人代表组成，对于不同的项
目而言 CCB 的权限大小不同，但 CCB 的决定通常是具备约束性的最终意见。）
PDCP plan decision check point 计划决策评审点
缩写  英文全称  中文
RMT  Requirement Management Team  需求管理团队，纯软件需求决策
RAT  Requirement Analysis Team  需求分析团队，软硬件需求分析
TMG  Technology Management Group  技术管理小组
CCB  Change Control Board  变更控制委员

CCB是变更控制委员会，不负责仲裁需求冲突。C项应更改我RAT、RMT



7	重构、坏味道习题
________________________________________


12：软件重构不能达到下面哪个目的：()
A：使软件更容易被理解
B：改进软件设计
C：消除软件 bugs
D：助你提高编程速度
选C。重构可以帮助发现bug，而非消除bug，因为重构一般不改变代码原理，只是改架构。


13：关于重构时机，下面说法中，错误的是：()
A：添加功能时，重构能够使得未来新增特性时更快速、更流畅
B：在修复错误时，应该聚焦问题本身，不建议重构，可以避免引入新的问题
C：专家 review 时重构，能够传递经验，改善设计，避免或减少代码持续腐化
选B，重构适合三个场景：新功能、修复错误、专家评审时适合


14：关于重构与测试，下面说法中，正确的是：()
A：重构前不管工作量多大都要先补充完善的单元测试，否则不能开始重构
B：测试方法包括单元测试、集成测试、系统测试，重构时我们只需要选择一种即可
C：在单元测试时，务求百分百的条件覆盖，这样才能保证重构没有问题
D：重构时，需要有对应的测试保护，用于验证重构后没有外在行为的变化
选D


17：关于 switch 语句，下面说法错误的是：()
A：switch 语句至少增加两个圈复杂度，所以遇到 switch 语句就应该重构掉
B：如果是面向对象语言，大多数情况可以用多态替换它
C：如果面向过程的语言，可以考虑使用表驱动或者策略模式重构，使其更简洁并容易扩展
选A，太绝对




18：关于类的成员变量，下面说法中，错误的是：()
A：如果不想类的成员函数定义过多的入参，可以将这些参数定义为类的成员变量
B：临时字段指，其内某个变量仅为某种特定场景而设，或者只在该对象某一段生命周期内
生效
C：对于临时字段，可以利用 Extract Class 把这些变量和其相关函数提炼到一个独立 class
中
选A，局部膨胀应该用参数对象、参数查询等方式来解决


19：类的继承体系有一系列重构手法，下面这些手法中,与类的继承体系无关的是：()
A：提炼类
B：函数上移
C：函数下移
D：提炼超类
选A。  类的继承没有提炼类的重构手法。


20：关于遗留系统的重构，对于选择重构的模块（或服务）如下因素中不是关键因素的是：
()
A：业务复杂度
B：需求变化频率
C：代码改动量
D：使用编程语言
选D。


21：如下代码，使用哪种重构手法能够使代码更加清晰：()

double GetPayAmount() {

    double result;

    if (isDead_) {

        result = DeadAmount();

    } else {

        if (isSeparated_) {

            result = SeparatedAmount();

        } else {

            if (isRetired_) {

                result = RetiredAmount();

            } else {

                result = NormalAmount();

            }

        }

    }

    return result;

}

A：移动语句
B：合并条件表达式
C：以卫语句取代嵌套条件表达式
D：提炼函数
选C。太多if else嵌套时，为避免嵌套过深，直接用卫语句，对不满足条件的情况直接返回，末尾再处理真正有用的业务。
参考：https://juejin.cn/post/6844903764336312333
修改后：


9：关于《g Clean Code 指导书》中对应重构层级定义下面那些是正确的：()
A：L0：功能正确
B：L1：无漏洞风险
C：L2：代码整洁
D：L3：架构敏捷
E：L4：持续演进
F：L5：全面可信
选ABCDE。只有L0-L4


10：什么时候不适合做重构：()
A：你参与的系统是关键系统，而且时间紧
B：你没有理解为何之前的开发人员是这样编写代码的，并且也没有想好应该重构成什么样
C：代码太混乱，设计完全错误，与其重构，还不如重写
选ABC


11：对于g代码度量评估模型中的度量项，描述正确的有：()
A：代码语句的度量项包括冗余代码、编译告警、静态告警、危险函数
B：代码函数的独立项包括函数行、代码重复率、圈复杂度
C：文件的度量项包括文件行、文件重复率
D：大目录指本目录节点下子目录数和文件数之和超过阈值的目录
选ABCD

12：关于重复代码，描述正确的有：( )
A：重复代码指完全相同的代码，有差异的不是重复代码
B：重复代码难以维护，容易造成修改遗漏
C：同一个类的两个函数有重复代码，可以考虑使用提取函数手法，提取公共代码
D：两个相互为兄弟的子类中有重复代码，先提取函数,再移到父类中
选BCD。


13：重构手法众多，但由基本手法组合出来的，这些基本手法包括：( )
A：重命名
B：提炼
C：内联
D：移动
选ABCD。


14：如下哪些是内联函数这个重构手法的动机：( )
A：提取功能，将部分代码提取到独立函数，方便复用和维护
B：提升可读性，提炼到一个独立的函数中， 并以这段代码的用途为这个函数命名，方便理
解
C：消除多余的间接性，将函数和被调用的代码合并了，方便理解
D：重新组织函数的过程中，把多个函数代码内联到一个函数中，方便后续重构
选CD

1（单选）一个父类有 3 个子类，父类中的一个方法只被其中一个子类引用，这时候应该如
何进行重构
A． 不用重构
B． 把子类合并到父类中
C． 加一个中间类继承父类，将方法移到这个中间类中，然后那个特别的子类再继承这个中间的类
D． 将方法移到子类中
选D


2（单选）有以下代码，下面重构说法正确的是 
(1) void setPoint(int x, int y, int z)
(2) void setColor(int x, int y, int z, int red, int green, int blue)
(3) void connectPoint(int srcX, int srcY, int srcZ, int destX, int destY, int destZ)
A． 对于setColor函数，应该将所有参数变成一个对象传入，void setColor(setColorParam)
B． 对于connectPoint函数，应该将参数进行封装传入，void connectPoint(Point src, Point
dest)
C．
D．
选B，B复用的价值更高


3（单选）关于重构方法，下列说法错误的有（）
A．一个函数的某个形参在当前没有被函数内任何代码使用，就应该去掉它。
B. 某个类的 getter 实例方法，既返回实例状态值，又修改了实例状态，这样违背了命令与
查询分离的原则，在使用过程中对于方法的调用者来说，
很容易因为设计与职责不符，造成意外的状态变更产生 bug。
C. 如果父类中的某个方法只有少数子类使用，那么可以将这个方法下移到相关子类中去
D. 即使少数子类有代码和功能相同的方法，也必须将这些方法上移到父类中去。
选C，高频题，重点理解：父类和子类函数上移下移以及成员变量的处理，除非只有一个子类用，才可以下移


4（单选）根据以下哪种白盒测试方法构建防护网，保证重构的质量？
A.针对待重构模块添加自动化测试
B.给系统补充全量自动化测试用例，结果全员在补充自动化用例时花费了很多时间
C.只针对待重构模块进行单元测试防护
D.单元测试用例可执行，但是执行结果需要人工确认
选C

5（多选）60 多种重构手法，基本手法包含哪几种（）？
A. 重命名(rename)
B. 提炼（extract）
C. 内联（inline）
D. 移动（move）
选ABCD

一个函数，参数不超过5个，行数不超过50行。

8（单选）关于重构与测试，下面说法中，正确的是：()
A：重构前不管工作量多大都要先补充完善的单元测试，否则不能开始重构
B：测试方法包括单元测试、集成测试、系统测试，重构时我们只需要选择一种即可
C：在单元测试时，务求百分百的条件覆盖，这样才能保证重构没有问题
D：重构时，需要有对应的测试保护，用于验证重构后没有外在行为的变化
选D

10（单选）关于过长参数列表的重构方法，描述错误的是：()
A：一个参数可以通过另一个参数查到时，可以使用以查询取代参数
B：多个参数有关联，总是同时使用，可以引入参数对象
C：某个参数是控标记用于区分函数行为，可以移除标记参数
D：为了减少函数入参，可以把参数改成全局变量
选D

过度使用断言检查每个细节，致使整个测试变得脆弱，考虑什么手段进行重构？ 
A、用测试替身替代外部依赖，根据需要将其封装到适配层中
B、将非强相关的用例进行拆分
C、识别无关细节，并将其从测试中移除
D、使用 bool 运算符替换位运算符
参考答案：选BC。D肯定跟断言没啥关系。

8	软件建模习题
________________________________________


#####软件建模#####
1：泛化是类与类的关系（继承），实现是接口与类的关系（实现），关联类似于类与成员
变量的关系（拥有关系），依赖类似于类与临时变量的关系（使用关系），组合是整体与局
部的关系，聚合是整体与个体的关系。
2：通过模型指导软件系统的具体实现。模型并不是软件系统的一个完备表示，而是所研究
的系统的一种抽象。
3：人-教师-教授是依赖关系，实线箭头，循环链表-队列是聚合关系，实线空菱形。
4：组件图和部署图可以结合在一起，描述哪些组件在哪些节点上运行
5：概念建模阶段不需要关心实现。
6：一个经理可以管理多个雇员，一个雇员只能被一个经理管：雇员和经理的方框直线连接，
雇员标注 1..n，经理标识 1。
7：UML 适用于描述复杂算法的执行流程：可以使用活动图。
8：时序图中：虚线是组件的生命线。


错误的描述 1：组件图(Component Diagram)描述系统中组件之间的物理关系
错误的描述 2：概念建模用于定义需要软件管理和处理的数据/信息，以及这些信息之间的关系，一般用数据视图表示，如类图，活动图。
错误的描述 3：软件建模是通过不同视角，采用不同的模型图对一个软件系统进行的完整描述
 
1      大纲
科目：软件设计与重构
可信设计
1)    掌握常见软件设计中各个领域应用的安全威胁及对应的安全设计方法，包括身份和访问控制管理、密钥管理、会话管理、安全设计、隐私保护、密码学算法应用等;2)    掌握常见的安全设计原则及安全设计方法，包括安全开发设计指导规则(HCSEC Golden Rules)、安全设计原则、安全设计模式、威胁建模工程方法（ASTRIDE）等9	2      需求分析
1)    掌握软件需求分析基本概念、流程、分析方法、需求分析的质量度量准则、系统资源占用分析方法；2)    理解需求分析需要关注的场景和维度、需求分析的场景和DFX识别方法3)    掌握需求分析的原则， ACT15立方架构设计原则、了解业界先进的架构和方案、业务领域国际标准/规范4)    掌握常见的软件架构和设计方法、常见的设计模式和架构模式软件建模和设计模式应用
1)    掌握常见软件建模方法及设计模式的应用，如封装、数据抽象、分类、聚集、概括、状态机模式、DSL、创建型模式、结构型模式、行为模式重构分析
1)    掌握软件设计及代码实现的宏观层面和微观层面的坏味道识别与处理方法，包括模块内代码、模块组件/服务间接口与代码设计；开发者测试
测试设计（含理念、方法、用例设计）1)    掌握测试基础理论与设计方法，包括单元测试、集成测试、系统测试2)    掌握组合测试设计方法、可靠性测试方法、性能测试方法、可测试性分析与设计方法3)    掌握用例质量评估方法、测试框架质量分析测试实现与执行1)    掌握白盒测试的框架搭建及应用2)    MOCK概念与使用方法（C/C++)3)    测试用例与环境解耦的方法(可独立执行，不依赖于外部条件)4)    覆盖率的分类(函数、代码行、分支覆盖率)5)    掌握测试框架扩展原则（易用性、稳定性、高效性）6)    掌握重构测试准备的基本原理与设计方法7)    测试代码重构常用技能方法开发者安全测试1)    理解DT-Fuzz基本原理，掌握Fuzz用例设计、编写和执行，熟悉相关工具的使用、FUZZ工具测试报告分析等2)    掌握程序异常行为分析、地址消毒报告分析、问题复现方法、优化测试用例方法等目的：
（1）       光背题  题目可能会变。要建立基础概念，理解+记忆
（2）       建立基础概念需要时间消化，所以有空就看看
（3）       代码题不要心慌，先看选项，针对性分析

 
10	3      UML 软件建模
10.1	3.1      概念
面向对象的建模标准，即UML(Unified Modeling Language)统一建模语言， 是面向对象开发中一种通用的图形化建模语言.(内部能对应到代码，比如接口/方法依赖/调用/类继承等)
10.2	3.2      分类
（蓝底代表静态模型，灰底代表动态模型，红字代表重点掌握。）10.2.1	3.2.1        类结构：
长方形垂直地分为三层，以此放置类的名称、属性和方法。属性和方法都需要标注可见性符号，+代表public，#代表protected，还可以用冒号:表明属性的类型和方法的返回类型。
关系：类关系从强到弱依次是：继承（泛化）>实现>组合>聚合>关联>依赖
举例：https://www.awaimai.com/patterns/uml考点：
(1)    关联关系有四种：双向关联、单向关联、自关联、多重数关联双向的关联可以有两个箭头或者没有箭头，单向的关联或自关联有一个箭头
在多重性关系中，可以直接在关联直线上增加一个数字，表示与之对应的另一个类的对象的个数。
•	1..1：仅一个
•	0..*：零个或多个
•	1..*：一个或多个
•	0..1：没有或只有一个
•	m..n：最少m、最多n个 (m<=n)(2)    .UML，一个Manager可以管理1到多个Employee，一个Employee仅能被一个Manager管理。其关系类图是怎么样的？ A(3)    B从A继承，一个C与一个到多个D组成B，关系类图是什么样的？(4)    10.ULM类图中整体与局部的关系 D
A 泛化
B 依赖
C 实现
D 聚合
10.2.2	3.2.2        顺序图
参与者是对象，不是类； 过程是消息流，不是数据流。(1)    有以下时序图，描述正确的是A．“曹操”“刘备”“诸葛亮”是类，不是对象 （反了）
B．“攻击”动作会调用“曹操”中的方法（调用刘备中的“怎么办”）
C． 图中虚线表示生命线，对象在这一时期内存在
D．图中调用顺序没有先后关系（有）
(2) 软件建模是通过不同视角，采用不同的模型图对一个软件系统进行的完整描述（错误）
答案：通过模型指导软件系统的具体实现。模型并不是软件系统的一个完备表示，而是所研究的系统的一种抽象。
(2)    以下属于动态模型图的是（BD）
A: 类图 B: 顺序图 C: 部署图 D: 状态图
(3)    用于描述两个对象之间消息交互的UML图是（C）
A: 用例图 B: 类图 C: 顺序图 D: 组件图
(4)    （多选）类图的6种关系中，比聚合关系强的是（）BC
A: 依赖 B: 泛化 C: 组合 D: 关联
(5)    用例图中的Include关系是对应的UML四个关系中哪一种关系（D）
A: 关联 B: 泛化 C: 实现 D: 依赖
(6)    以下关系表达方式正确的是（AD）11	4      开发者测试
11.1	4.1      概述
测试是验证的过程，在可以接受的出错风险下，投入最低的测试工作量，测试的目的是获得最大收益。
√ 测试是发现缺陷的过程、减少软件总成本的过程。（正确）
× 测试是证明软件正确的过程、证明软件没有缺陷的过程、建立软件发布信心的过程。（错误）
  （单选）正交四原则要求通过所有测试？
A.正确
B.错误
答案：A正确
解析：正交四原则是指简单设计的四个基本原则，包括1）通过所有测试 2）尽可能消除重复 3）尽可能清晰表达 4）更少的代码元素
11.2	4.2      覆盖方法：注意： 判定覆盖：判定覆盖只关心判定表达式的值（真/假），而条件覆盖涉及到判定表达式的每个条件的值（真/假）。在逻辑电路中，判定覆盖可以保证一个逻辑门的翻转，二条件覆盖可以保证这个逻辑门的每一个输入的翻转。
判定覆盖和条件覆盖中间不存在 充分/必要 的逻辑关系
举例，对于  if (x > 5 && y < 10)  
（x=6,y=9）  (x=4,y=9)   可以保证判定覆盖；
(x=6,y=11)   (x=4,y=9)   可以保证条件覆盖；1.        void someFuntion() {
2.               // other code
3.        if (x > 5 && y < 10) {
4.            doSomething();
5.            s = “a”;
6.        }
7.         
8.        if (x == 2 || z > 15) {
9.            s = “bb”;
10.     }
11.     }
12.      (1) 为以下流程图所示的程序段设计一组测试用例，下面（）用例满足判定/条件覆盖标准的最小的测试数据组  C
   
A. (X=0, Y=0); (X=1,Y=0); (X=15, Y=9); (X=17, Y=6)
B. (X=0, Y=0); (X=1, Y=1); (X=15,Y=9); (X=17, Y=11)
C. (X=0, Y=0); (X=17, Y=11)
D. (X=0, Y=0); (X=1, Y=0); (X=17, Y=6)
(2) 对下图所示流程图采用白盒测试方法进行测试，若要满足路径覆盖，则至少需要（）个测试用例？ D 6(3) 测试和外部环境分析，不能依赖外部环境，否则测试用例随机失败，符合测试的什么特征（）A
A. 可重复性
B. 隔离型
C、一致性
11.3	4.3      性能测试
(1) 有四次请求耗时分别为：10ms，1000ms，100ms，2ms，计算TP50、TP90
1、将请求时延按照升序排列: [2ms,10ms.100ms,1000ms]
2、TP50 = 请求数 * 50% = 4*50% =2
3、取第二个请求时延 10ms，即TP50 可以满足百分之50网络请求最低耗时为 10ms
4、TP90 = 请求数 * 90% = 4*90% =3.6 进位取整 为4
5、取第四个请求时延 10ms，即TP90 可以满足百分之90网络请求最低耗时为 1000ms
(2) 性能测试的时候需要观察（）指标 ABCD
A. 资源指标（CPU、内存、文件句柄等）
B. 业务指标（响应时延、呼叫成功率等）
C. 数据库指标（CPU占用率、内存占用率、SQL读写速度等）
D. 真实用户体验（对于端到端体验类业务）
12	5      代码坏味道
12.1	5.1      Duplicated Code（重复的代码）
如果你在一个以上的地点看到相同的程序结构，那么可以肯定的：设法将他们合而为一，程序会变得更好。
12.2	5.2      Long Method（过长函数）
12.3	5.3      Large Class（过大类）
12.4	5.4      Long Parameter List（过长参数列）
入参数建议不大于5个。通过构造结构体入参，或者函数拆分解决。
12.5	5.5      Divergent Change（发散式变化）
多种不同领域的原因引起同一个类的变动。原因是类的职责过多不单一。
考虑拆分子类。
13.     class Drive()
14.     {
15.        DriveCar()；
16.        DrivePlane()；
17.        DriveBoat()；
18.     }
无论car、plane、boat发生变化，这个大类就需要修改。所以最好对三个领域都简历自己的子类，修改的时候不会影响其他类。
12.6	5.6      Shotgun Surgery（散弹式修改）
遇到某种变化，需要在不同类中修改。原因：类职责不明确。修改方法：把相同功能的方法抽象到一个类中。
  面向对象设计的基本原则中的开闭原则指出软件要对扩展开放，对修改关闭。违反开闭原则可能造成的坏味道有（）BD
A. 基本类型偏执(Primitive Obsession)
B. 散弹式修改(Shotgun Surgery)
C. 过长参数列表(Long Parameter List)
D. 发散式变化(Divergent Change)12.7	5.7      Feature Envy（依恋情结）
函数对某个类的兴趣高过对自己所处类的兴趣，通常焦点便是数据，某个函数为了计算某个值，从另一个对象那调用几乎半打的额取值函数。
将数据和处理数据的方法放在一起。
12.8	5.8      Data Clumps（数据泥团）（从具体意义考虑）
两个类中相同的字段、许多函数签名中相同的参数。这些总是绑在一起出现的数据真应该拥有属于它们自己的对象。意义强相关的数据没有建造一个数据容器。
12.9	5.9      Primitive Obsession（基本型别偏执）（从数据类型考虑）
对象的一个极大的价值在于：它们模糊（甚至打破）了横亘于基本类型数据和体积较大类之间的界限。
很多参数都是用基本类型：
19.     public class Employee
20.     {
21.          public Employee(string firstName, string lastName, int iD,string contactCellNo,string ssn){
22.                 FirstName = firstName;
23.                 LastName = lastName;
24.                 ID = iD;
25.                 PhoneNumber = contactCellNo;
26.                 SSN = ssn;
27.        }
28.          public string FirstName { get; set; }    
29.     public string LastName { get; set; }    
30.     public int ID { get; set; }    
31.     public string PhoneNumber { get; set; }    
32.     public string SSN{ get; set; }}
将他们抽象成一个对象，对象里面set get操作
下列函数重构方法正确的是，（基本类型偏执）B
(1) void setPoint(int x, int y, int z)
(2) void setColor(int x, int y, int z, int red, int green, int blue)
(3) void connectPoint(int srcX, int srcY, int srcZ, int destX, int destY, int destZ)A．对于setColor函数，应该将所有参数变成一个对象传入，void setColor(setColorParam)
B． 对于connectPoint函数，应该将参数进行封装传入，void connectPoint(Point src, Point dest)
C．
D． 
12.10	5.10   Switch Statements（switch惊悚现身）
面向对象程序的一个最明显特征就是：少用switch（或case）语句。从本质上说，switch语句的问题在于重复（duplication）。你常 会发现同样的switch语句散布于不同地点。如果要为它添加一个新的case子句，你必须找到所有switch语句并修改它们。面向对象中的多态 （ploymorphism）概念可为此带来优雅的解决办法。
大多数时候，一看到switch语句你就应该考虑以[多态]来替换它。问题是多态该出现在哪儿？switch语句常常根据type code（型别码）进行选择，你要的是[与该type code相关的函数或class]。所以你应该所用Extract Method（110）将switch语句提炼到一个独立函数中，再以Move Method（142）将它搬移到需要多态性的那个class里头。此时你必须决定是否使用Replace Type Code with Subclasses（223）或Replace Type Code with State/Strategy（227）。一旦这样完成继承结构之后，你就可以运用Replace Conditional with Polymorphism（225）了。
如果你只要在单一函数中有些选择事例，而你并不想改动它们，那么[多态]就有点杀鸡用牛刀了。这种情况下Replace Parameter with Explicit Methods（285）是个不错的选择。如果你的选择条件之一是null，可以试试Introduce Null Object（260）。
  switch语句，为了考虑日后的多个case的扩展，哪些重构方法好？
a.采用if—else，5个一组避免圈复杂度过高，抽取函数出来 ---- 这个不选
b.采用设计模式
c.采用配置表的方式
  配置表的一个例子：
switch  label:
case LABLE1:
       FUNC1
       break
case LABEL2
       FUNC2
       break
       …
变成：
table[]={
{ LABLE1，FUNC1 }
{ LABLE2，FUNC2 }
…
}for(;;)
{
       if label == LABELn
              FUNCn
              break;
}
   消息处理程序，有公告消息头格式，。。。，目前代码使用switch语句，要重构 ，为了消除switch语句，降低复杂度，方便扩展：CD
A、职责链
B、switch改成if else
C、表驱动
D、类继承、工厂12.11	5.11   Parallel Inheritance Hierarchies（平行继承体系）
散弹式修改的一个特殊例子，为某个类增加一个子类，必须也为另一个类相应增加一个子类。
12.12	5.12   Lazy Class（冗赘类）
如果一个类的所得不值其身价，它就该消失。类中包含几乎没用的组件。
12.13	5.13   Speculative Generality（夸夸其谈未来性）
为了不确定的未来扩展，过分增加预留属性、接口、中间层。
12.14	5.14   Temporary Field（令人迷惑的暂时值域）
  局部变量有哪些重构方法
【在不影响功能的情况下把多个同种类型的局部变量合成一个 错的】12.15	5.15   Message Chains（过度耦合的消息链）
如果你看到用户一个对象请求另一个对象，然后后者请求另一个对象，然后再请求另一个对象这就是消息链。
Employee->EmployeeConfig->Config
Employee ->Config
12.16	5.16   Middle Man（中间转手人）
12.17	5.17   Inappropriate Intimacy（狎昵关系）
12.18	5.18   Alternative Classes with Different Interfaces（异曲同工的类）
12.19	5.19   Incomplete Library Class（不完美的程序库类）
12.20	5.20   Data Class（纯稚的数据类）
12.21	5.21   Refused Bequest（被拒绝的遗贈）
12.22	5.22   Comments（过多的注释）
注释本身并不是坏事。但是常常有这样的情况：一段代码中出现长长的注释，而它之所以存在，是因为代码很糟糕。如果你觉得一个代码片段没有注释就无法理解，请先尝试重构，试着让所有注释都变得多余。
  以下代码，存在哪些坏味道（多选）：BC
33.     public String getType(String i) {
34.         StringBuilder k = new StringBuilder();
35.         for (int j = 0; j < i.length(); j++) {
36.             // 判断第一个数字是否为负数
37.             if (j == 0) {
38.                 k.append(" ");
39.             } else {
40.                 if (i.charAt(0) == '=') {
41.                     k.append(" = ");
42.                 } else {
43.                     k.append(String.valueOf(i.charAt(0)));
44.                 }
45.             }
46.         }
47.         return k.toString();
48.     }
A. 依恋情结。对参数i作了大量的charAt操作。
B. 烂用注释，注释没有自注释，并且注释内容与实际意义不符。
C. 命名不规范，不能表达实际意思。
D. 过度耦合消息链。反回值过度依赖入参细节。
  给出一个代码，识别坏味道 cd
replaceMinusOper(String oper)
{
       没记住，大概是把-号用+*/替代  之类的。
}
a.数据泥团
b.基本类型偏执
c.变量命名不好
d.注释不好
  关于代码注释下列说法哪些是正确的（）ACD
A. 对于某些确实难以表意清晰的代码，允许通过注释来澄清意图，例如某种复杂算法。
B. 在当前交付版本无法提供的功能，在代码中通过todo注释先进行标记，在下一个交付版本再实现。--本版本完成
C. 用代码本身来阐述意图。
D. 警示其他程序员操作可能会出现的某种后果。13	6      重构
确定重构方法之前，要先明确坏味道，才能对症下药
重构首先要逻辑清楚，其次才是视觉清楚。
技巧：先看选项，判断选项的逻辑（单选与互斥的选项，必选其中之一）。明显错误的，一眼能看出来的不要选 绝对肯定或者否定语气的会有问题。  代码有问题，需要重构的是：B
49.     a.getRecord
50.     Record getRecodr(String name) {
51.         Item it = findItem(name);
52.         Record rd ;
53.         if (it != null) {
54.             rd = it.getRecord();
55.         }
56.         return null;
57.     }
58.     b.getNode  ------- get函数里new了一个新节点
59.     Node getNode(String name) {
60.         Node nd = findNode(name);
61.         if (nd==null) {
62.             nd = new Node();
63.         }
64.         return nd;
65.     }
66.     c.setNum
67.     d.getNum
  某产品现有代码中有一个超大函数，有850行代码18个参数和31个局部变量，以下手法中可以直接减少该函数代码量并减少参数和局部变量个数的有哪些() AD
A. 通过提炼函数（Extract Method）的手法，提取一批功能内聚、名称通俗易懂的函数
B. 为了提高可读性，决定引入解释性变量（Introduce Explaining Variable），把其中某些复杂表达式结果放到命名良好的临时变量中
C. 将函数内联化（Inline Method）将封装不良的下层函数直接展开到当前函数中
D. 引入参数对象（Introduce Parameter Object），把参数封装成一个或几个类，将参数封装成对象后提高了代码的可读性，并且该参数对象也可以供多个方法调用，以后如果增加删除参数，方法本身不需要修改，只需要修改参数对象就可以
  关于代码格式，下列说法错误的是（）B
A. 每行代码展现一个表达式或一个子句，每组代码行展示一条完整的思路，这些思路应该用空白行隔离开
B. 让“代码能工作”是专业开发人员的首要要求，代码格式的要求尽量交给自动转换工具去处理，开发人员优先将代码功能开发完成
C. 代码格式不可忽略，必须严肃对待。代码格式关于沟通，而沟通是专业开发者的头等大事
D. 同一个文件内一个函数调用了另一个，应该把他们尽量放在一起，方便阅读
  仔细阅读下面代码，考虑下面的重构思路，哪些可以采纳：AB
68.     ULONG OlcCfgProc( VOID* recvMsg )
69.     {
70.         ULONG ret;
71.         ULONG paraNum = 0;
72.         ULONG objID = 0;
73.         ULONG loop;
74.         ULONG threshold ;
75.      
76.         /*从消息中提取参数*/
77.         paraNum = GetAllParaNum(recvMsg);
78.         for ( loop = 0; loop < paraNum; loop++ ) {
79.              objID = GetParaID( recvMsg, loop );
80.              switch ( objID ) {
81.                   /* 获取漏桶配置阈值 */
82.                   case OLC_BUCKET_CONFIG_VALUE:
83.                     threshold = GetParaULONGVal( recvMsg, loop );
84.                     break;
85.      
86.                   default:
87.                     return VOS_ERROR;
88.              }
89.          }
90.      
91.         if ( threshold > 100 ) {
92.             OutString("error");
93.             return VOS_ERROR;
94.         }
95.      
96.         /* 设定漏桶配置阈值 */
97.         ret = SetBucketConfig(threshold);
98.         if ( ret != VOS_OK ) {
99.             OutString("error");
100.          return VOS_ERROR;
101.      }
102.   
103.      return VOS_OK;
104.  }
A. 该函数重构时可分解为2个主要的子函数，分别是：参数提取函数和配置处理函数
B. 对threshold的有效值判断应该放到SetBucketConfig函数内部去完成
C. SetBucketConfig函数随着功能扩展，还会增加其他参数配置，此时可扩展一个resv输入参数项进行预留
D. 函数中两处使用OutString函数，可以提炼到一个函数中，供返回应用
  下面对于重构的理解错误的是（ ）C
A. 重构时要保证代码修改的安全性，保持业务功能不变。
B. 在修改问题时重构，修改问题时适当重构可以使修改问题更简单，并且更容易理解减少出错的可能，并且有问题回归测试进行质量保证。
C. 重构不能改变模块内的函数调用关系。
D. 在增加功能的时候重构，重构新增功能涉及到的相关代码可以简化新增功能的修改，并且随功能测试验证可以保证重构质量。
  从提升代码可读性角度看，下面代码段哪个重构方法最好（）A
1.        long DisabilityAmount()
2.        {
3.            if (seniority < START)
4.                return 0;
5.            if (monthsDisabled > END)
6.                return 0;
7.            if (isPartTime)
8.                return 0;
9.            // compute the disability amount
10.     }
11.     A.
12.     long DisabilityAmount()
13.     {
14.         if (IsNotEligibleForDisability()) {
15.             return 0;
16.         }
17.      
18.         // compute the disability amount
19.     }
20.      
21.     bool IsNotEligibleForDisability()
22.     {
23.         return ((seniority < START) || (monthsDisabled > END) || (isPartTime));
24.     }
25.     B.
26.     long DisabilityAmount()
27.     {
28.         if (seniority < START)
29.             return 0;
30.      
31.         if (monthsDisabled > END)
32.             return 0;
33.      
34.         if (isPartTime)
35.             return 0;
36.      
37.         // compute the disability amount
38.     }
39.     C.
40.     long DisabilityAmount()
41.     {
42.         if (seniority < START)
43.         {
44.             return 0;
45.         }
46.         if (monthsDisabled > END)
47.         {
48.             return 0;
49.         }
50.         if (isPartTime)
51.         {
52.             return 0;
53.         }
54.         // compute the disability amount
55.     }
56.     D.
57.     long DisabilityAmount()
58.     {
59.         if (seniority < START) {
60.             return 0;
61.         }
62.         if (monthsDisabled > END) {
63.             return 0;
64.         }
65.         if (isPartTime) {
66.             return 0;
67.         }
68.      
69.         // compute the disability amount
70.     }
  （单选）有效代码超过（）行的函数就是过长函数?
A. 30 B. 20 C. 50 D.100
答案：C
  一个函数的参数个数最好不要超过（）个？
A. 4 B. 5 C. 6 D. 3
答案：B
  （多选）60多种重构手法，基本手法包含哪几种（）？
A. 重命名(rename)
B. 提炼（extract）
C. 内联（inline）
D. 移动（move）
答案：ABCD
  对于下面根据单板状态获取模板模式的函数，存在嵌套过深的问题，可以使用（）重构手法降低嵌套深度。A
71.     int getTemplateMode(Board board) {
72.         double result;
73.         if (board.isOnline) {
74.             if (board.isSpecialMode)  {
75.                 result = getSpecialMode(board.type);
76.             } else {
77.                 if (board.isBackup) {
78.                     result = getTemplateModeFromActiveBoard(board.slot);
79.                 } else {
80.                     result = getNormarlMode(board.type);
81.                 }
82.             }
83.         } else {
84.             result = TEMP_MODE_OFF_LINE;
85.         }
86.         return result;
87.     }
A. 使用卫语句，代码改为类似如下: （https://blog.csdn.net/u012810020/article/details/51821087）
88.     int getTemplateMode(Board board) {
89.     if (!board.isOnline) {
90.         return TEMP_MODE_OFF_LINE;
91.     }
92.     …
B. 使用分解条件表达式(Decompose Conditional),将判断条件拆分为一个个独立的函数
C. 采用合并条件表达式(Consolidate Conditional Expression)，将行为一致的条件判断合并
D. 通过多态取代条件式,定义一个基类，每个分支都是一个子类，将实现放在子类中
  一个父类被3个子类继承，随着代码的不断修改，父类中的某个方法只被其中一个子类S使用，这时候比较合理的重构方法是（）B
A. 子类S与父类关系密切，所以将子类S合并到父类
B. 将该方法移动到子类S中
C. 修改该方法名字，并在名字中显式标明只用于子类S场景。
D. 在父类中将该方法设置为private属性，并将S设置为父类的友元类，使得只有S可以访问该方法
注意：所有加flag标志位的选项都大概率有问题的，因为违反了高内聚低耦合的原则。
  关于重构方法，下列说法错误的有( ) B
A. 某个类的getter实例方法，既返回实例状态值，又修改了实例状态。这样违背了命令与查询分离的原则，在使用过程中对于方法的调用者来说，很容易因为设计与职责不符，造成意外的状态变更，产生Bug。所以需要将状态修改的代码搬移出去成为单独的状态变更方法，实现命令与查询分离。
B. 如果父类中的某个方法只有少数子类使用，那么可以将这个方法下移到相关的子类中去（只有一个）
C. 即使少数子类有代码和功能相同的方法，也必须将这些方法上移到父类中去。
D. 一个函数的某个形参在当前没有被函数内的任何代码使用，就应该去掉它
少数子类方法相同则一定要上移到父类。
  依恋情结(Feature Envy)的含义是，一个模块/class 的函数，直接调用了另一个模块/class的大量数据，访问自己的数据少，访问其他模块/class的数据多。这样就违反了“数据和操作封装在一起”的原则，关于有依恋情结的代码重构策略，下列描述错误的是（）A
A. 可通过字段上移(Pull Up Field)的方式将数据提到父类中。（重构的一个原则就是方法上移，数据下移）
B. 如果仅仅是函数的部分代码访问另一个对象的数据，运用提炼函数(Extract Method) 将这部分代码移到独立的函数中。
C. 解决依恋情结的基本原则是将总是一起变化的东西放在一块儿。
D. 如果一个函数明显应该被移到另一个地方，可运用搬移函数(Move Method)。
  下面代码重构，用的代码重构方法是（）B
原代码：
1.        class Employee
2.        {
3.            protected String _name;
4.            protected String _id;
5.         
6.        }
7.        class Manager extends Employee
8.        {
9.            private int _grade;
10.         public Manager(String name, String id, int grade)
11.         {
12.             _name = name;
13.             _id = id;
14.             _grade = grade;
15.         }
16.     }
17.      
18.     class Enginner extends Employee
19.     {
20.         public Enginner(String name, String id)
21.         {
22.             _name = name;
23.             _id = id;
24.         }
25.     }
26.   重构后代码:
27.     class Employee
28.     {
29.         protected String _name;
30.         protected String _id;
31.      
32.         protected Employee(String name, String id)
33.         {
34.             _name = name;
35.             _id = id;
36.         }
37.     }
38.      
39.     class Manager extends Employee
40.     {
41.         private int _grade;
42.         public Manager(String name, String id, int grade)
43.         {
44.             super(name, id);
45.             _grade = grade;
46.         }
47.     }
48.     class Enginner extends Employee
49.     {
50.         public Enginner(String name, String id)
51.         {
52.             super(name, id);
53.         }
54.         .......
55.     }