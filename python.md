# 命名
## G.NAM.01 使用统一的命名风格
建议
标识符命名风格原则
基于开源或外部代码进行开发或维护时，可以保持原有命名风格
未明确要求的标识符命名风格，自行选择，保持风格统一
小写下划线：模块、包、函数、全局变量、类变量、实例变量、方法名称、函数或方法的参数、局部变量
大驼峰：类、异常
大写下划线：全局常量、类常量
1. 包、模块名使用意义完整的英文描述，采用小写加下划线的风格命名
   1. 包名和模块文件名中不能包含除下划线以外的标点符号和特殊符号，建议使用小写英语单词或者使用几个小写英语单词的组合
2. 类名
   1. 类名通常是名词或名词短语
   2. 可以使用单个英语单词或多个单词的组合
   3. 类名不应该使用动词，也应该避免Data、Info这样的模糊词
3. 函数、方法
   1. 可以使用小写英语单词，一般使用动词
   2. 可以使用单词的组合，一般使用动词、介词和名词，使用单下划线连接单词，所有字母都小写
   3. 如果一个函数不想对外公开，是仅供模块内其他函数调用的辅助函数，建议以单个下划线开头，表示函数是protected的，使用`from module_name import *`时不会导入
4. 类或对象的私有成员一般用单下划线开头；对于需要被继承的基类成员，如果想要防止与派生类成员重名，可用双下划线开头
   1. Python没有严格的似有权限控制，业内约定俗成的用单下划线开头来按时此成员仅供内部使用。双下划线开头的成员会被解释器自动改名，加上类名作为前缀，其作用是防止在类继承场景中出现名字冲突，并不具有权限控制的作用，外部仍然可以访问。双下划线开头的成员应该只在需要避免名字冲突的场景中使用，比如设计为被继承的工具基类。
5. 变量、类的数据成员、函数的参数采用小写加下划线的风格命名
   1. 可以使用小写英语单词，一般使用名词
   2. 可以使用单词组合，使用单下划线连接单词，所有字母都小写
   3. 如果变量名不得不与内置函数、内置模块、标准库名字重合，可以后面加一个下划线以作为区分
6. 常量
   1. 常量应使用大写英文单词或者使用单下划线连接的大写英语单词组合来命名，表示在程序中不需要修改的固定值。常量命名要尽量表达完整的语义
   2. 类常量及枚举命名同样建议以大写加下划线的风格命名。

## G.NAM.02 命名要有明确含义，以提升代码的可读性
建议
1. 命名中若使用了特殊约定或缩写，建议注释说明
2. 命名需要有明确含义，在能够准确表达含义的前提下，应该尽量简短
3. 建议遵循标识符长度正比于标识符的作用域原则。作用域很小且无歧义的情况下，允许使用单字符命名变量，除此以外，避免使用单个字符或字幕与数字的简单组合
4. 对于单个字符命名的场景，不应该使用字符l、I、o等命名，在某些字体中，这些字符与数字1和0难以辨认，如果确实要以l作为变量，使用L替换。

## G.NAM.03 “self”应是实例方法的第一个参数，“cls”应是类方法的第一个参数
建议
类方法是被`@classmethod`装饰的函数
Python语言常规约定
类的实例方法至少要有一个位置参数self，类方法至少要有一个位置参数cls，并且都必须是第一个

## G.NAM.04 避免在无关的标识符或无关的概念之间重用名字，避免因重名而导致的意外赋值和错误引用
建议
Python的函数/类定义和C语言不同，函数/类定义语句实际上是给一个名字赋值，因此重复定义一个函数/类的名字不会导致错误，后定义的会覆盖前面的。但是重复定义很容易掩盖编码问题，也不利于可读性，应予以禁止。Python在解析一个被引用的名字时遵循LEGB顺序（local，enclosed，global，builtin）从内层一直查找到外层。内层定义的变量会遮盖外层的同名变量。
1. 标识符的命名避免和内置函数、内置类以及Python关键字重复
2. 避免重复定义函数、类方法或类
3. 标识符命名避免与当前导入的模块名称重名
4. 避免在函数中定义与参数名称相同的变量，这可能导致潜在的错误

## G.NAM.05 除了需要重写魔法函数、对象之外，不推荐使用双下划线开头且双下划线结尾的标识符来命名一般对象
建议
Python语言的约定，以双下划线开头且结尾的标识符，用来命名Python内部特殊的魔法函数或对象

# 注释
## G.CMT.01 模块文档字符串写在文件的顶部，Shebang和文件编码声明之后，导入部分之前的位置，不需要缩进
建议
文档字符串使用三引号作为定界符，以前导三引号开头，结束三引号要自成一行
模块文档字符串通常可以包含当前模块文件的简要描述以及该模块中的类、函数等信息，这些信息以每个一段的形式摘要描述。详细功能描述建议和上面的总体描述空一行分隔。
文档字符串的第一个摘要行可能与前导三引号在同一行，也可能在下一行
模块文档字符串结束后空一行，然后编写其他内容
## G.CMT.02 类的文档字符串写在类声明所在行的下一行，并向后缩进4个空格
建议
与内部定义的方法、数据成员具有相同的缩进量
对于功能非常明了的类，可使用单行文档字符串，使用三引号作为定界符，并且前导三引号和结束三引号保持在同一行
多行文档字符串使用三引号作为定界符，以前导三引号开头，结束三引号要自成一行，前导三引号不一定要自成一行
类的多行文档字符串的内容通常可以包含其功能描述，实例属性或公共方法，这些信息以每个一段的形式摘要描述。如果该类可能被子类化，并且具有用于子类的附加接口，则该接口应在文档字符串中单独列出。类构造方法的详细细节可以在类文档字符串记录也可以在其自己的文档字符串记录，其他方法的详细细节通过其自己的文档字符串记录。
## G.CMT.03 公共函数的文档字符串写在函数声明所在行的下一行，并向后缩进4个空格
建议
单行/多行文档字符串，三引号同上
公共函数的多行文档字符串内容通常包含功能描述、参数、返回值、异常描述等，信息以每个一段的形式摘要描述。异常描述除描述函数内部抛出的异常外，还应该说明异常的含义及什么条件下抛出该异常。
Google风格，Pycharm reStructedText风格都可，保持一致即可
## P.01 注释跟代码一样重要，应按需注释
尽量通过清晰的软件架构、良好的标识符命名来提高代码可读性；在需要的时候，才辅以注释说明。对晦涩难懂的代码、命名，应该考虑重构而不是添加注释。
修改代码时，也要保证其相关注释的一致性。
注释语言由开发团队统一决定，最擅长、沟通效率最高的语言。
## G.CMT.04 代码的注释位置和格式应该在项目内保持统一
建议
代码的注释位置和格式有两种风格，应在项目内保持统一的风格：
1. 注释应该与其描述的代码保持同样的缩进，放在被注释代码的上方相邻位置，使用#开头，#后面一个空格然后写注释文本
2. 代码行的行尾添加注释，为了提高可读性，行尾注释应该至少离开代码2个空格，#后面一个空格然后写注释文本
## G.CMT.05 正式交付给客户的代码不应包含TODO/FIXME注释
建议
TODO注释一般用来描述已知待改进、待补充的修改点。FIXME注释一般用来描述已知缺陷。都应该有统一风格，方便文本搜索统一处理
在版本开发阶段，可以使用此类注释用于突出标注，交付前应该全部处理掉
## G.CMT.06 文件头注释应该包含版权许可信息
建议
文件头注释应放在模块文档字符串之前，应包含版本许可信息。如果需要在文件头注释中增加其他内容，可以在版权说明的后面进行补充。
版权许可信息建议放在shebang和文件编码声明之后
版权所有 (c) xxxx公司 2012-2020
Copyright (c) xxxx Co., Ltd. 2012-2020. All rights reserved.
1. 年份可以根据实际需要进行修改，前者是文件首次创建年份，后者是最后文件修改年份，二者可以一样。对文件有重大修改时，必须更新后面年份，如特性扩展、重大重构等。
2. 版权所有可以使用子公司
3. 同一项目内，版本许可信息的位置和风格应保持一致

# 格式
## G.FMT.01 程序块应该采用4个空格缩进风格编写
建议
选择结构、循环结构、异常处理结构、函数定义、类定义、成员方法定义、类方法定义、静态方法定义、with块等语法结构，代码相对于头部应该有4个空格的缩进
相同级别的代码应具有相同的缩进量，虽然不影响程序运行，也不允许在逻辑上具有相同缩进层次的代码在视觉上具有不同的缩进量
使用空格和跳格，虽然视觉效果 一样，但禁止在缩进时混合使用跳格和空格，否则程序无法运行，提示错误`SyntaxError: inconsistent use of tabs and spaces in indentation`因此，新项目必须使用纯空格来代替跳格
## G.FMT.02 行宽不超过120个字符
建议
行宽包含代码以及注释等，行宽不宜过长，否则不利于阅读。控制行宽可以间接地引导程序员去缩短函数、变量的命名，减少嵌套的层数，精炼注释，提升代码可读性。建议每行字符数不要超过120个；除非超过120能显著增加可读性，并且不会隐藏信息。较长的语句、表达式或参数以及注释行要进行换行处理。
**例外：**
对于换行导致内容截断，不方便查找、拷贝的字符串（如长URL、命令行等）可以不换行。
## G.FMT.03 合理安排空行
建议
使用空行可以凸显出代码块的相关程度，能提升代码可读性。但是过多的空行并不能带来更多好处，反而可能降低代码的可读性。
1. 减少空行，仅在需要特别凸显代码块逻辑分组时使用连续空行，并且最多连续2个空行，比如顶级的类定义或函数定义之间，需要2个空行
2. 类的方法定义之间空一行
3. 相对独立的逻辑代码块之间，变量说明之后建议空一行

## G.FMT.04 用空格突出关键字和重要信息
建议
建议加空格的场景：
1. 逗号、分号、冒号只在后面加空格
2. 比较操作符，赋值操作符，算数操作符，逻辑操作符等双目操作符的前后加空格
3. `*`、`**`等作为操作符时，前后可以加空格，但若和更低优先级的操作符同时使用并且不涉及括号，则建议前后不加空格
4. **函数参数类型定义时**，冒号前不应使用空格，冒号后需要加空格，**参数有默认值则赋值操作符前后需要空格**。函数返回值类型定义前后建议添加空格

不建议加空格的场景：
1. **函数定义语句中的参数默认值**，调用函数传递参数时使用的等号，建议不加空格
2. 对于包含关系的两个对象用“.”连接时，前后不应加空格
3. 括号内侧，左括号后面和右括号前面，不需要加空格，多重括号之间不必加空格
4. 紧贴索引切片或被调用函数名，开始的括号前，不需要加空格
5. 切片的3个参数之间的冒号前后不需要加空格
6. 行尾不建议加空格

## G.FMT.05 导入部分应该置于模块注释和文档字符串之后，模块全局变量和常量声明之前
建议
如果文件中定义了类似`__all__`、`__version__`这种全局变量，那么导入部分应该放在这类定义的后面，但`__future__`模块的导入例外，它的导入必须放在文档字符串之后，其他内容之前。
## G.FMT.06 每行只能导入一个模块
建议
如果从同一个模块中导入多个对象可以在同一行加载，如果一行代码太长，可以放到元组中，然后换行
## G.FMT.07 导入部分应该按照标准库、第三方库、应用程序自定义模块的顺序排列导入
建议
导入部分按照分组顺序导入，每个分组之间应该留一个空行
每个分组内部，应该按照包的完整路径的字母顺序排列导入
如果文件中包含`__future__`模块的导入，那么该语句应该被放在所有导入的最前面
例外：
1. 针对部分模块不在标准python安装路径下，需要进行导入优先级调整的情况下，被调整模块与其他模块之间的先后顺序可以不满足
2. 针对使用`evenlet.monkey_patch`（猴子补丁）进行模块修改的情况下，被修改模块与其他模块间的先后顺序可以不满足

## G.FMT.08 一行只写一条语句
建议
Python虽然支持分号分隔的多条语句，但编写程序时不建议使用这种风格的排版，推荐一行只写一条语句，并且在行尾不加分号。多条语句在一行的明显缺点是调试时无法单步执行。

## G.FMT.09 合理地运用换行和缩进
建议
当语句过长或可读性不佳时，需要在合适的地方换行。换行时建议将操作符、连接符放在行末，表示“未结束，后续还有”。新行应按照缩进要求进行缩进。
1. 如果一条语句过长，且其中有函数调用、方法调用、类调用或类似的语法，可以采用隐式续行的写法，左括号应跟函数名在同一行，右括号应跟最后一个参数在同一行，然后在圆括号内某个参数后面逗号位置换行，换行后后面几行开始的位置，与同组表达式的第一个左对齐。
2. 如果列表、元组、字典、集合类似的对象的语句过长，建议要么左括号与右括号在同一行，要么在左括号后进行第一次换行，右括号单独成一行。
3. 不建议复杂且较长的表达式，如果一定要使用，建议在每一段后面进行换行，即每段分别独立一行

## G.FMT.10 代码的行外结束符LF和CRLF不应该混用
UNIX系统应使用LF作为行尾结束符，Windows系统应使用CRLF作为行尾结束符

# 数据模型
## G.TYP.01 需要精确数值计算的场景，应该使用decimal模块，且不要用浮点数构造Decimal
建议
浮点数在一个范围很广的值域上提供了很好的近似，但是它不能产生精确的结果。涉及精确的数值计算（货币、金融等），建议使用decimal模块。如果对性能要求较高而且需求简单方便时可使用float。
需要注意的是，在构造Decimal实例时，使用浮点数容易导致精度缺失，应该使用字符串格式的数值构造Decimal。
使用Decimal进行运算时，可以指定计算精度。
```python
from decimal import Decimal, getcontext

getcontext().prec = 6
print(Decimal(1) / Decimal(7))   # 输出 0.142857， 精度为6
```
## G.TYP.02 浮点类型数据判断相等不要直接使用==
要求
由于浮点数在计算机表示中存在精度的问题，数学上相等的数字，经过运算后，其浮点数表示可能不再相等，因而禁止使用相等运算符==来比较浮点数是否相等。另外，也不要把浮点数作为HashMap的Key使用。
考虑浮点数的精度问题，可在一定的误差范围内判定两个浮点数值是否相等。误差根据实际需要进行定义。
Python 3.5 以后的版本新增了`math.isclose()`方法，可以实现两个浮点数的比较，参数`rel_tol`。如果指接近相等则返回`True`，否则返回`False`。

## P.02 合理使用字符串格式化
字符串格式化遵守以下原则：
1. 对于简单的字符串串联，使用`+`操作符即可，对于复杂的字符串格式化 方法，优先推荐使用`.format()`方法或f-字符串。
2. 尽量避免使用运算符`%`进行格式化和连接字符串。

## P.03 合理使用字符串引号
1. 在同一个文件中，保持使用字符串引号的一致性，使用单引号或双引号引用字符串，并在同一文件中沿用。
2. 在字符串内需要引号的情况推荐使用另外一种引号，以避免使用反斜线进行串内转义。
3. 多行字符串建议使用三重双引号而非三重单引号。当且仅当项目中使用单引号来引用字符串时，才可能会使用三重单引号为非文档字符串的多行字符串来标识引用。文档字符串必须使用三重双引号。不过要注意，通常用隐式行连接更清晰，因为多行字符串与程序其他部分的缩进方式不一致。
- 当多行字符串是业务逻辑处理的一部分时，不建议再前导三引号之前换行。

## G.TYP.03 不要使用难以理解的字面量
建议
难以理解的字面量是指通过代码的上下文难以明确业务含义的字面量，包括整型字面量、浮点数字面量、布尔字面量和字符串字面量。
有时候字面量在上下文中是能够理解其含义的，有时候则不能，比如
1. 没有通过标识符命名来解释数字含义
2. 对于可能会在代码维护中修改其值的常量，符号命名限制了其取值

解决途径：
1. 对于单点使用的难以理解的字面量，按需增加注释说明
2. 对于多处使用的难以理解的字面量，应该定义为常量，并通过符号命名自注释
- 装饰器中的重复字符串在上下文中是能够理解其含义的，可以不抽取为常量字符串

## G.TYP.04 建议使用`if seq`或者`if not seq`的方式判断序列是否为空
建议
在条件表达式中虽然可以直接使用`len()`判断序列是否为空，但Python语言本身有非常简单而高效的方式来推断字符串、列表、元组、字典、集合的隐式布尔值，使用`if seq`或`if not seq`判断序列是否为空，是一种非常Pythonic的编程方式，同时也是PEP8推荐的方式。

## G.TYP.05 对序列使用切片操作时，不建议使用负步进值进行切片
建议
Python提供了`example_list:end:stride`形式的写法，以实现步进切割，也就是从每stride个元素中取一个出来。但如果stride值为负，则会使代码难以理解，特定使用场景下还会造成错误。
尽量使用stride为整数，并且尽量不要同时使用start、end、stride。如果确实要执行这种操作，建议将步进切割过程和范围切割过程分开，使代码更清晰。
例外：
1. 在处理类似字符反转需求时，可使用负步进值进行切片`a[::-1]`
2. 对性能特别敏感，最好通过一次切片完成操作的场景，可使用负步进值进行切片`a[::-1]`

## G.TYP.06 同一个字典表达式中各个键值不要相同
要求
同一个字典表达式中的各个键值不要重复，如果存在重复的键值，后面的键值对会覆盖前面的键值对，应避免

## G.TYP.07 使用`dict[key]`获取value时需要注意保证key在有效的范围内
建议
Python的字典`dict`可以用key获取其对应的value。但是当key在`dict`的key值列表中不存在时，直接使用`dict[key]`获取value会报`KeyError`，所以需要注意从代码层面保证key在有效的范围内。可以通过以下方法来处理或避免这类错误：
1. 尽量避免直接使用`dict[key]`的方式从字典中获取value，如果一定要用，需要注意对key not in dict的情况做异常处理
2. 使用`dict.get(key)`方法获取value，并且在使用`dict.get`方法时应设置默认值并对返回值进行检查，如果不设置默认值的话则默认为`None`
3. 对于性能要求不高的场景，推荐使用`collections`模块中`defaultdict`类，当取一个字典中不存在的key值时，它不会报错或者取到的值为`None`，而是会返回一个设定的默认值

例外：
从代码层面保证使用的key一定在`dict`存在，那么也可以直接使用[]下标取值。注意如果仅仅是开发者个人判断，建议使用处理或避免`KeyError`的方式

## G.TYP.08 必须使用`isinstance`判断变量类型
要求
使用`isinstance`代替`type`比较来判断变量类型，判断一个对象的类型是否在多个类型中，尽量使用单次`isinstance`调用
`isinstance`不仅会判断对象是否是目标类型的实例，还会判断对象是否是目标类型子类的实例，或者是否能通过目标类型的`__instancecheck__`校验

## G.TYP.09 建议优先使用对应的内置函数来判断对象的类型或行为
建议
比如推荐使用`callable()`、`isinstance()`等内置函数来代替`hasattr()`判断对象的类型或行为。因为对应的内置函数可以更好地覆盖各种场景，并且不会随着语言的演进而失效
如果没有对应的内置函数，则仍可使用`hasattr()`函数判断对象是否具有特定的行为
因为历史原因，`isinstance`无法判断仅实现了`__getitem__`的可迭代对象

# 运算符
## G.OPR.01 对除法运算和模运算中的除数为0的情况做相应保护
要求
如果除法或模运算中的除数为零可能会导致程序终止，因此需要对除数为0的情况做相应保护。保护措施主要是以下3种：
1. 在除法运算前，对除数是否为0进行判断
2. 通过捕获除0异常`ZeroDivisionError`的方式，来防止程序意外终止
3. 明确参数的使用约束，由调用方确保除数不为0
- 允许依靠Python异常机制直接终止执行的程序、框架可以不做除零模零的防护

## G.OPR.02 与`None`作比较要使用`is`或`is not`，不要使用等号
要求
`is`判断是否指向同一个对象，判断两个对象的id是否相等，`==`会调用`__eq__`方法判断是否等价，判断两个对象的值是否相等

## G.OPR.03 禁止使用is运算符做值相等性比较
要求
`is`和`is not`是用来检查两个实例是否引用同一个对象的，禁止用`is`或`is not`运算符在内置类型之间做比较

## G.OPR.04 不建议使用海象运算符
建议
可能使代码更难理解与维护。建议重构代码并用赋值语句替代海象运算符

## G.OPR.05 应该使用`is not`运算符而不是`not ... is`
建议
可读性考虑

## G.OPR.06 应该使用`not in `测试成员关系
建议
可读性和一致性考虑

# 表达式
## G.EXP.01 尽可能使用隐式布尔值
建议
选择结构的条件表达式中
以下对象会被看作`False`：
- 常量`None`和`False`
- 值为0的数值类型，包括`fractions.Fraction(0,1)`
- 空的序列和容器类型，包括`range(8,5)`类似的情况
- 该对象的类定义了`__bool__`方法，且该方法返回`False`
- 否则，该对象的类定义了`__len__`方法，且该方法返回0

## G.EXP.02 如果`lambda`表达式的内容超过一行，建议定义为常规函数
建议
函数体比较简单的匿名函数，通常可以嵌套在函数`map`、`filter`、`sorted`、`max`、`min`、`reduce`和列表方法`sort`中使用
建议定义为常规函数的场景：
1. `lambda`表达式的内容较长，例如超过120个字符的`lambda`表达式建议改为常规函数
2. `lambda`表达式的结构较复杂，例如`lambda parameter:exp1 if condition1 else (exp2 if condition2 else exp3)`类似或更多层嵌套的`lambda`表达式建议改为常规函数
3. 标准库中`operator`中已提供的简单运算，不建议再通过重新定义的`lambda`表达式的方法实现，建议直接使用`operator`中的现有方法

## G.EXP.03 不应将`lamda`表达式赋值给变量，应该使用常规函数
建议
不便于调试，因为所有的`lambda`表达式都没有名字，即使将它们赋给变量，在返回的错误堆栈信息中，显示也是`<lambda>`，而常规函数在返回的错误堆栈信息中显示的是该函数的名字
例外：
在字典排序或者和其他高阶函数一起使用时，可以把简单的`lambda`函数赋值给变量，用作参数

## G.EXP.04 推导式和生成器表达式仅用于简单的逻辑表达
建议
避免包含多个`for`子句或筛选表达式，复杂的场景用循环来表达
简单的推导式和生成器表达式提供了更紧凑、高效地创建容器类型和迭代器的能力，有助于提升代码的易读性，并且生成器表达式还能避免创建完整的容器

# 控制语句
## G.CTL.01 同一个函数/方法的所有分支返回语句必须统一为显式或都为隐式，不允许混合使用
要求
Python的函数/方法没有显式的返回语句`return`时，会默认返回`None`。如果一个函数/方法的多个分支有的使用显式`return`语句，有的不使用显式`return`，那么对于调用者来说就无法使用一个统一的类型来处理这个函数的返回对象，可能在返回对象的后续处理过程中发生错误。
也可以使用类型注解，显式地提示出函数/方法预期的返回对象类型，需要注意的是，类型注解并不真正检查返回值类型和参数类型，只是一种预期

## G.CTL.02 所有的代码都必须是逻辑可达的
要求
跳转语句所在代码块中，在它之后的代码及代码块将永远无法执行到，但后续附近代码的修改可能触发它们执行，存在潜在风险，因此，这类逻辑不可达的代码需要删除掉，或者调整代码位置，把逻辑修改正确

## G.CTL.03 避免在条件/循环控制语句中包含过多的条件
建议
`if`语句中的表达式尽量清晰直接，避免陷入具体的条件判断细节。条件判断细节可以在使用`if`条件判断之前用`bool`变量代替或封装函数/方法
建议不超过3个

## G.CTL.04 建议使用`for x in iterable` 的方式循环处理可迭代对象
建议
使用`for i in range(x):`语句，然后在循环体内对序列用下标取元素是一种较为传统的编程习惯，有很多缺点：容易越界，在循环体内修改i容易出错，可读性差。建议直接用`for x in iterable`方式，直接取序列中的每一个对象进行处理
有些场合下，需要在处理时使用每个元素的序号，这时可以使用`enumerate`内置函数来给元素加上序号形成元组

## G.CTL.05 建议使用单个下划线代替循环体中未使用的循环变量
建议
尽量减少代码中出现的冗余变量
同样适用于返回值序列解包场景

# 函数与方法
## G.FNM.01 禁止使用可变对象作为参数默认值
要求
在Python程序中，函数的参数默认值只会被初始化一次，并且被重复利用。当参数默认值为可变对象时，若函数调用时不传入参数值，则对该参数的默认值进行的任何操作实际上操作的是同一个对象。
因此，仅可使用基本类型字面常量或常量作为参数默认值：整数、bool、浮点数、字符串、None
建议使用None作为默认值，在程序中重新初始化为空列表
通常不建议一个参数支持多个数据类型，但若确实存在，也可以用单行if else解决

## G.FNM.02 函数和`lambda`表达式不应该使用外部的循环代码中定义的变量
要求
嵌套函数和`lambda`表达式可以引用当前作用域内定义的变量。
如果在循环体中定义了函数/`lambda`并引用了循环变量，则在循环体外调用该函数时，将始终获取到该循环变量的终值，导致结果与预期不一致
这种情况通常发生在希望延迟执行一些预定义好的函数时发生，如：提前定义一系列的操作，在某种条件下再执行这一系列自动循环生成的操作
因此：
1. 如果在循环内定义函数/`lambda`表达式并且在循环内调用，则不做限制
2. 如果在循环内定义函数/`lambda`表达式并且在循环外调用，该函数/`lambda`表达式不应引用循环中定义的变量

反例：
嵌套函数中采用了外部循环体的变量
`lambda`中采用了外部循环体的循环变量
嵌套函数中将循环变量作为参数的默认值，使得函数在定义时即进行赋值，的确能解决只获取终值的问题，但是代码不易维护，非推荐写法
`lambda`定义时将循环变量作为新变量的值，虽然的确能解决只获取终值的问题，但是代码不移维护，非推荐写法
for循环中使用带循环变量的map，map是延期执行的

正例：
嵌套函数不引用循环变量，将函数与参数值同时保存，形成`[(函数，参数)]`的映射列表
如果在循环中立即调用函数或使用lambda表达式，而不是循环结束后才调试或使用，可以在函数或lambda表达式中使用外部循环中的变量，比如用list将map强制计算并转为list格式，是立即执行的

## G.FNM.03 当函数参数个数较多且有相关性时，建议通过class/namedtuple/dataclass等具名形式进行封装
建议
`__init__`不受函数参数个数的限制
当函数参数个数较多，并且参数之间没有相关性时，建议根据函数/方法职责单一的原则，进行函数重构
如果函数明确判断只使用一次，也不存在“数据泥团”风险的情况下，可以不封装

## G.FNM.04 不要将没有返回值的函数调用结果赋值给变量
要求

## G.FNM.05 当函数返回值个数较多时，建议通过class/namedtuple等具名形式进行封装
建议

## G.FNM.06 使用return代替StopIteration来结束生成器
要求
从Python3.7起，生成器退出时的StopIteration将会被解释器转换为RuntimeError

## G.FNM.07 建议完备处理函数的返回值和异常
建议
当函数的调用没有产生任何作用同时忽略了函数返回值，即函数返回值未参与程序业务逻辑处理或预期异常处理，在这种情况下函数调用无效，应及时删除

# 变量作用域
## P.04 合理使用全局变量
全局变量使用建议遵循以下原则：
1. 使用全局变量会导致业务代码和全局变量之间产生数据耦合，并且很难跟踪数据的变化，建议避免使用全局变量
2. 鼓励使用模块级的常量，并将有相关关系的常量设计为枚举或类常量，而不是分散在全局。但是不建议将所有的常量定义到一个常量类或模块中，避免出现“口袋”类和模块
3. 如果必要使用全局变量，应该通过下划线开头命名，将全局变量声名为模块的内部变量，并且将其排除在`__all__`之外
4. 变量或者常量都应该放在与它表达的业务相关的地方

## G.VAR.01 禁止在变量的生命周期内修改其类型
要求
Python是动态类型语言，允许变量被赋值为不同类型对象，但也可能导致运行时错误
给变量赋值时，值的类型应该和变量的类型匹配，禁止变量在其生命周期内的值类型发生变化

## G.VAR.02 禁止使用`global`关键字声名不存在的外部变量
要求
关键字`global`可用于创建全局变量或声名要修改已定义的全局变量
应尽量避免在函数中修改外部变量的值，对于仅需要读的场景，不使用`global`关键字

## G.VAR.03 禁止覆盖外部作用域中的标识符
要求
禁止出现当前局部作用域遮盖更外层作用域中的标识符，造成阅读困扰

# 类与面向对象
## P.05 类的成员属性应该根据封装的需要来区分访问权限
私有成员、保护成员
可以阻止外部访问我们不希望被访问的私有属性，也可以借助一些工具，比如`pylint`，的静态扫描能力对不符合保护设计的访问进行告警

## G.CLS.01 如果子类和父类中都有`__init__`方法，则子类中的`__init__`方法必须正确调用其父类`__init__`方法
要求
如果子类和父类都有初始化方法，子类其实是重写了父类的构造方法，如果不显式调用，父类的构造方法不会被执行

## G.CLS.02 重写方法的方法签名应该和被重写的方法一致
建议
子类重写父类方法时，如果方法签名不一致，则会覆盖父类同名方法的实现。这种重写行为违反了里式替换原则，使子类丢失了一部分父类功能。因此，建议子类在重写父类方法时，保持与父类同名方法的方法签名一致。

## G.CLS.03 建议避免在继承内置类型的同时重写其魔法函数
建议
自定义类可以继承自Python的内置类型，此时需要额外注意其魔法函数的完整性，因为这些内置类型的魔法函数之间通常有关联，修改其中一个通常意味着要联动修改另一个和它相关的魔法函数，否则会出现预期之外的执行结果
组合一个字典到自定义类上，而不是以字典作为父类创建子类，这样实现的功能范围和对基本功能的影响都清晰易懂、完全可控

## G.CLS.04 建议在实现抽象类时使用`abc`模块
建议
抽象类经常被用于面向对象设计者表达自己的设计意图，并且要求后续的开发者严格按照自己的设计来泛化实现
继承自`abc`模块`ABC`类、并使用`abstractmethod`修饰抽象方法的类真正具有的抽象类的强约束功能，不能被实例化，和严格要求子类实现方法，严格看护了面向对象设计作者的设计意图

## G.CLS.05 子类调用父类初始方法的方式，建议用super类辅助
建议
菱形继承场景下父类类名的初始化写法会导致顶层父类初始化函数被调用多次
super写法不与父类类名绑定，而是MRO

## G.CLS.07 类的方法不需要访问实例时，建议定义为`staticmethod`或`classmethod`
建议
类的方法不需要访问实例时，普通的实例方法会造成使用过程中冗余的实例生成、回收过程
例外：
在子类重写父类实例方法时，如果不需要访问实例也不需要访问类属性或方法时，依照里式替换设计原则，子类的方法可以保持为实例方法

## G.CLS.08 禁止在`__init__`方法外定义实例属性
要求
会造成多个类实例属性的存在生命周期不一致，为后续跨方法访问埋下隐患
类属性与类实例属性是不同的概念，通常定义在类代码块中与方法同级，不在此条约束中

## G.CLS.09 重写类的魔法函数时必须返回其原型指定的类型
要求
类的魔法函数（`__len__`，`__bool__`等）可以依赖解释器隐式地辅助完成对象的基本功能。由于和解释器的框架代码耦合，如果重写类的魔法函数时与其原型返回值不一致，将在很多基本功能中出错，如真值判断、比较等

## G.CLS.10 未实现的数值运算类型魔法函数必须返回`NotImplemented`而不是抛出`NotImplementedError`
要求
从而能在别的类中寻找方法完成功能

## G.CLS.11 表面在类外或者子类中访问父类受保护的成员
建议
不建议通过直接访问、跨实例访问的形式访问类的protected类实例属性
Python的名字改写特性对private类型设计的类实例属性访问，同样是一种破坏封装的行为，不鼓励
protected类型的成员可以在继承关系中被继承，并以方法的形式提供外部访问功能

## G.CLS.12 类实例较多时，推荐使用`__slots__`来加强管理类的成员属性
建议
显式地为对象绑定数据成员属性，并不针对每个实例自动生成`__dict__`和`__weakref__`属性。`__slots__`可以是字符串，可迭代对象，或是以多个成员属性命名的字符串组成的序列。
通过使用`__slots__`可以减少实例所占用的内存大小，但相对的需要注意一些问题：如丧失了`__dict__`和`__weakref__`属性，如果需要也可以加回`__slots__`，因此在类实例较多时，一般一百万级别以上，可以考虑定义类的`__slots__`来节省内存

# 异常处理
## G.ERR.01 `try`代码块内只包含可能抛出异常的代码段
建议
1. 只将可能引发异常的最小代码段放入`try`代码块内，保证逻辑的相对独立性
2. 一个`try`代码块只处理一段可能引发异常的代码

## G.ERR.02 用异常来表示异常，而不是用返回值表示异常
建议
在函数单一职责的理念下，常常会出现嵌套较深的函数调用关系，此时如果选择用返回值来表示异常，会产生多层逻辑判断，降低代码的可读性和扩展性

## G.ERR.03 异常的类型定义必须继承自`Excption`
要求
按照已知异常->`Exception`的顺序捕捉时，不需要关注对键盘中断、进程退出、生成器结束等异常的特殊处理
禁止使用非异常类型作为`raise`对象，如`NotImplemented`、可迭代对象等
不建议使用`BaseException`作为最终的异常捕获类型，但如果明确某些自定义异常不需要被`except Exception`捕获，可以继承自`BaseException`

## G.ERR.04 对异常做类型转换时要保留原始异常的错误调用栈信息
建议
如果丢失了错误调用栈信息，会给问题定位、运维等带来不必要的麻烦
如果原始异常的错误调用栈信息中包含敏感数据，可以不遵守本规则，但建议将原始异常的错误调用栈信息脱敏后记录到日志中，确保问题可定位追溯

## G.ERR.05 使用有明确业务属性的异常类型
要求
1. 只捕获必须在本`try-except`代码块内处理的异常，对于其他预料外的异常，交给上层函数捕获，或者透传到外部以暴露问题
2. 禁止直接使用`except：`语句，如果要捕获所有类型的异常，必须使用`except BaseException：`进行显式说明，否则容易与设计预期不一致，且该问题容易被代码维护人员忽视
3. 禁止在多个`except`语句的第一顺位使用`except Exception：`或`except BaseException：`异常捕获只处理与本代码块有逻辑关联的异常，捕获宽范围的异常会感知到更多的信息，不符合最小知识原则
4. 在主动抛出异常时，要明确异常类型，不要直接抛出`Exception`或`BaseException`，应该放在最后，用于处理未知异常
- 在顶层调用函数中，在确信已知异常均已在下层函数中得到处理的情况下，可以直接捕获`Exception`

## G.ERR.06 `raise`语句必须包含异常实例
要求
使用`raise`语句时，Python会查找被`except`语句捕获的最后一个异常，如果不存在对应的异常，抛出的异常类型为`RuntimeError`，丢失了原始错误调用信息

## G.ERR.07 避免抑制或忽略异常
建议
捕获异常，并对异常做出相应的处理
除非某些业务场景需要忽略某些异常，并且这些异常不需要做日志记录

## G.ERR.08 禁止通过异常泄露敏感数据
要求
例如，在对公网用户开放的web服务接口，返回的错误信息中禁止包含`ImportError`和`OSError`等潜在泄露内部文件目录结构的内容
提供身份认证的函数，当发生用户名或密码认证失败时，返回的异常类型禁止明确标明是用户名错误或是密码错误，以免攻击者结合日志文本通过暴力探测获取用户名清单
传入文件，规定合法的文件目录，与其他路径进行隔离

## G.ERR.09 在单个except代码块内，禁止重复捕获同类异常
要求
在较长的软件生命周期中，会带来可读性和可维护性问题
1. 禁止同时捕获父类异常和子类异常
2. 禁止重复捕获同一个异常

## G.ERR.10 同时使用多个except语句时，要注意异常捕获的顺序
建议
捕获异常的语句应放在其父类之前，先捕获父类的话，后面不会被执行

## G.ERR.11 避免使用`SystemExit`和`sys.exit()`，主进程入口中例外
建议
一定要使用时，需要调用者对资源进行必要的处理，并继续向上抛出异常

## G.ERR.12 合理地使用`object.__exit__`处理异常
建议
在实现`__exit__`方法时，要明确对异常的处理方式
1. 如果要屏蔽某个异常，必须返回`True`
2. 如果要某个异常保持外抛，返回`False`或`None`
3. 如果要抛出新的异常，执行`raise X()`

## G.ERR.13 捕获异常后避免直接重新抛出
建议
无效逻辑会影响代码可读性

## G.ERR.14 不要使用return、break、continue或抛出异常使finally块非正常结束
要求

# 并行与并发
## P.06 不要依赖于内置类型的原子性
GIL保证在同一时刻Python虚拟机中只能有一个线程在运行
只在字节码指令级别做线程切换，很多内置类型的操作是线程安全的
在并发场景中遇到不确定是否线程安全时，建议使用锁来保护临界区资源
一个多线程共享的计数器，可以通过使用`threading.Lock`类来保护计数自增

## P.07 Python多线程使用于阻塞式IO场景，不适用于并行计算场景
Python的标准实现是CPython
存在GIL
另一个实现是IPython，但并不是最常见的Python实现

## G.CNP.01 建议为communicate传入超时参数来防止子进程死锁或失去响应
建议
在使用subprocess模块来管理子进程时，给communicate方法传入timeout参数，以避免子进程死锁或失去响应

# 包与模块
## P.08 使用package对module进行分层管理
基于高内聚原则设计包和模块，将相关功能的模块放到同一个包内，将同类功能的对象放到同一个模块内
包和子包的目录下必须包含__init__.py文件，以确保Python解释器能够正确地将该目录识别为包或子包

## P.09 使用__all__声明允许外部访问的变量、函数和类
与Java等语言不通，Python不支持在模块内严格限制外部可访问的对象清单。作为模块的提供者，应该通过__all__声明公共接口，并保证在模块版本声明周期内的公共接口稳定和跨版本兼容
作为模块的使用者，避免使用未包含在__all__清单内的接口（内部接口），因为提供者不会承诺内部接口的稳定性，随着版本演进可能有不兼容修改

## G.IMP.01 使用绝对路径导入模块
建议
1. 应该使用绝对路径，避免使用相对路径导入。使用绝对路径可以清晰明确地知道所导入模块的所属包和完整路径，在出现导入错误时更容易定位，能够减少调整代码路径时的配套修改工具
2. 如果代码的路径较深，可以使用相对路径导入，本项目库可以使用相对路径
3. 禁止对外部库，包括系统库、三方库和二方库，使用相对路径导入
4. 禁止对同一个包的导入，同时使用绝对路径和相对路径，即便是在不同文件中导入，也不要混用，不利于代码维护
- 同时需要具备可执行和可导入的文件内，使用相对路径导入，会发生导入错误

## G.IMP.02 使用`from…import…`语句的注意事项
建议
禁止使用`from…import *` ，该方法会导入模块内的所有非 _前缀的对象，同名对象的覆盖、各对象所属模块的模糊，都不利于调测和维护
使用别名，规避易混淆

## G.IMP.03 避免使用`__import__`函数
建议
使用`importlib.import_module`函数替代`__builtins.__import__`

# 标准库
## P.10 注意根据场景选用copy或deepcopy来完成浅拷贝或深拷贝
注意对于数字、字符串和其他原子类型对象等，没有被拷贝的说法。如果对其重新赋值，也只是新创建一个对象，替换掉旧的而已

## G.PSL.01 避免使用已经被标记为弃用并有明确替代的方法
建议
代码运行出现Deprecationwarning

## G.PSL.02 在datetime的使用过程中注意时区的影响，时区敏感的场景建议显式指定时区
建议
在未指定tz可选参数时，会按照操作系统设置的时区显示时间

## G.PSL.03 修改sys.path时注意避免模块重名问题
sys.path是Python在执行import语句时搜索模块使用的路径列表，由当前目录、系统环境变量、库目录、.pth文件配置组合而成，直接修改之后将作用于当次Python进程运行生命周期中所有import语句
原则上sys.path只应该根据用户的系统配置来生成，默认的sys.path应该就可以支持模块的搜索过程，不应该在代码里面直接修改。如果确实需要修改，需要注意尽量不要影响其他模块的搜索顺序，以免ImportError
建议使用sys.path.append代替sys.path.insert(0, my_directory)，此外也可以修改系统PYTHONPATH环境变量达到相同目的
建议以项目或子项目的根目录作为待添加入sys.path的路径，然后从根目录的包名开始搜索符号，而不要把同一个项目下所有可能有import操作的路径都单独添加一次，这样的设计会给修改和维护工作造成很大麻烦，也不利于项目结构的理解和演进
如果一定要修改sys.path，建议使用append、extend等方法加在sys.path的最后，保证不影响其他标准库、三方包加载

## G.PSL.04 建议用functools.wraps定义函数装饰器
避免被装饰函数内部属性被破坏

# 代码工程
## P.11 建议尽量使用标准库中的功能来替代直接调用操作系统的系统命令

## G.PRJ.01 建议为启动文件添加启动文件头
类Unix操作系统上使用启动头（Hashbang）已明确指定运行此文件的解释器版本，推荐使用这种方式指定，有助于防止非预期版本的解释器执行文件。
解释器版本不作要求时，可以使用`#! /usr/bin/env python`声明，选择系统的PATH变量中指定的第一个Python解释器来执行代码
执行入口文件添加，不推荐所有文件都添加
Windows操作系统可忽略此条

## G.PRJ.02 建议为启动文件设置执行入口
建议
用于启动子进程的代码文件必须使用`if __name__ == "__main__":`确定是顶层代码作用域之后才能正常启动子进程

## G.PRJ.03 产品代码不要包含任何调试入口点
要求
交付前必须删除所有调试相关的代码
`pdb.set_trace()`

## G.PRJ.04 建议统一项目内的编码方式保持一致，推荐UTF-8
建议

## G.PRJ.05 不用的代码直接删除，不要注释掉
要求
若再需要，考虑移植或重写这段代码

## G.PRJ.06 正式发布的代码及注释内容不应包含开发者个人信息
